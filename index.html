<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>å˜èªå¡¾ã‚¢ãƒ¼ã‚±ãƒ¼ãƒ‰ï¼ˆè½ä¸‹ãƒ¯ãƒ¼ãƒ‰ï¼‰</title>
<style>
  :root{
    --bg:#0b1020; --card:#121a33; --ink:#e8eeff; --muted:#a9b3d6;
    --good:#38d996; --bad:#ff5c7a; --warn:#ffcc66; --line:rgba(255,255,255,.12);
    --shadow: 0 10px 24px rgba(0,0,0,.35);
    --radius:18px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
    background: radial-gradient(1200px 800px at 20% 10%, #1a2a66 0%, rgba(26,42,102,0) 55%),
                radial-gradient(1000px 700px at 80% 0%, #4a1f6c 0%, rgba(74,31,108,0) 55%),
                var(--bg);
    color:var(--ink);
  }
  /* --- Mobile safe-area / dynamic viewport fixes (top cut-off prevention) --- */
  :root{
    --sat: env(safe-area-inset-top);
    --sab: env(safe-area-inset-bottom);
  }
  /* Keep content away from notch/status bar while allowing header background to extend */
  header{
    padding-top: calc(14px + var(--sat));
  }
  /* Overlays should also respect safe area */
  .overlay{
    padding-top: calc(16px + var(--sat));
    padding-bottom: calc(16px + var(--sab));
  }
  /* Use dynamic viewport units on mobile to avoid URL bar cropping */
  #stageWrap{height: min(62vh, 520px); height: min(62dvh, 520px);}
  @media (max-width:520px){
    #stageWrap{height: min(62vh, 460px); height: min(62dvh, 460px);}
  }

  header{
    padding: 14px 14px 10px;
    position: sticky; top:0; z-index:10;
    backdrop-filter: blur(10px);
    background: linear-gradient(to bottom, rgba(11,16,32,.92), rgba(11,16,32,.65));
    border-bottom:1px solid var(--line);
  }
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .title{
    display:flex; align-items:baseline; gap:10px;
  }
  .title h1{font-size:16px; margin:0}
  .title .tag{font-size:12px; padding:3px 9px; border:1px solid var(--line); border-radius:999px; color:var(--muted)}
  .pill{
    padding:8px 12px; border:1px solid var(--line); border-radius:999px;
    background: rgba(255,255,255,.04);
    display:inline-flex; align-items:center; gap:8px;
    box-shadow: 0 6px 16px rgba(0,0,0,.12);
  }
  .pill strong{font-size:12px}
  .pill span{font-size:12px; color:var(--muted)}
  .btn{
    border:1px solid var(--line); background: rgba(255,255,255,.06);
    color:var(--ink); padding:10px 12px; border-radius:14px; cursor:pointer;
    box-shadow: var(--shadow);
    transition: transform .06s ease, background .12s ease;
  }
  .btn:active{transform: translateY(1px)}
  .btn.primary{background: rgba(56,217,150,.18); border-color: rgba(56,217,150,.35)}
  .btn.danger{background: rgba(255,92,122,.14); border-color: rgba(255,92,122,.35)}
  .btn.ghost{box-shadow:none}
  .btn.small{padding:8px 10px; border-radius:12px; font-size:12px}
  .btn:disabled{opacity:.5; cursor:not-allowed; transform:none}
  main{
    max-width: 980px; margin: 0 auto;
    padding: 14px;
    display:grid; gap:12px;
    grid-template-columns: 1.3fr .7fr;
  }
  @media (max-width: 900px){
    main{grid-template-columns:1fr}
  }
  .card{
    background: rgba(18,26,51,.78);
    border:1px solid var(--line);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    padding: 12px 12px 10px;
    border-bottom:1px solid var(--line);
    display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
  }
  .card .hd h2{margin:0; font-size:14px}
  .card .bd{
    padding:12px;
    overflow:auto;
    flex: 1 1 auto;
  }
  .muted{color:var(--muted)}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}

  /* Game stage */
  #stageWrap{position:relative; width:100%; height: min(62vh, 520px);}
  #stage{
    position:relative; width:100%; height:100%;
    border-radius: 16px;
    background: linear-gradient(to bottom, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:1px solid var(--line);
    overflow:hidden;
  }
  #stage::after{
    content:"";
    position:absolute; left:0; right:0; bottom:0; height:64px;
    background: linear-gradient(to top, rgba(0,0,0,.35), rgba(0,0,0,0));
    pointer-events:none;
  }
  .laneHint{
    position:absolute; inset:0;
    background:
      linear-gradient(to right, rgba(255,255,255,.06) 1px, rgba(0,0,0,0) 1px) 0 0 / 25% 100%;
    opacity:.22;
    pointer-events:none;
  }
  .enemy{
    position:absolute;
    padding: 10px 12px;
    border-radius: 14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.08);
    box-shadow: 0 12px 24px rgba(0,0,0,.25);
    min-width: 160px;
    max-width: min(260px, 60vw);
    transform: translate(-50%, -50%);
    user-select:none;
  }
  .enemy .top{display:flex; align-items:center; justify-content:space-between; gap:10px}
  .enemy .w{font-weight:700; font-size:16px; letter-spacing:.2px}
  .enemy .lv{font-size:11px; color:var(--muted); padding:2px 8px; border:1px solid var(--line); border-radius:999px}
  .enemy .sub{margin-top:6px; font-size:12px; color:var(--muted); line-height:1.25}
  .enemy.good{border-color: rgba(56,217,150,.5); background: rgba(56,217,150,.14)}
  .enemy.bad{border-color: rgba(255,92,122,.5); background: rgba(255,92,122,.14)}

  .enemy.target{
    border-color: rgba(56,217,150,.95);
    background: rgba(56,217,150,.10);
    box-shadow: 0 0 0 2px rgba(56,217,150,.30), 0 18px 34px rgba(0,0,0,.38);
  }
  .enemy.target::after{
    content: "TARGET";
    position: absolute;
    top: -10px;
    left: 12px;
    font-size: 10px;
    padding: 2px 7px;
    border-radius: 999px;
    background: rgba(56,217,150,.90);
    color: #062b18;
    border: 1px solid rgba(0,0,0,.12);
    letter-spacing: .06em;
  }
  .enemy.boss{
    border-color: rgba(255,204,102,.55);
    background: rgba(255,204,102,.12);
  }
  .shake{animation: shake .18s linear 0s 2}
  @keyframes shake{
    0%{transform: translate(-50%,-50%) translateX(0)}
    25%{transform: translate(-50%,-50%) translateX(-3px)}
    50%{transform: translate(-50%,-50%) translateX(3px)}
    75%{transform: translate(-50%,-50%) translateX(-2px)}
    100%{transform: translate(-50%,-50%) translateX(0)}
  }

  /* HUD */
  .hud{display:flex; flex-wrap:wrap; gap:8px}
  .meter{display:flex; align-items:center; gap:10px}
  .bar{
    width: 160px; height: 10px; border-radius: 999px;
    background: rgba(255,255,255,.08);
    border:1px solid var(--line);
    overflow:hidden;
  }
  .bar > i{display:block; height:100%; width:100%; background: rgba(56,217,150,.6)}
  .bar.hp > i{background: rgba(255,92,122,.6)}
  .bar.boss > i{background: rgba(255,204,102,.7)}
  .kbd{font-size:11px; color:var(--muted); border:1px solid var(--line); padding:2px 6px; border-radius:8px}

  /* Answer area */
  .answers{
    display:grid; gap:10px;
    grid-template-columns: 1fr 1fr;
  }
  @media (max-width:520px){
    .answers{grid-template-columns:1fr}
    #stageWrap{height: min(62vh, 460px);}
  }
  .choice{
    width:100%;
    padding: 14px 12px;
    border-radius: 16px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.06);
    color:var(--ink);
    text-align:left;
    cursor:pointer;
    box-shadow: 0 10px 24px rgba(0,0,0,.22);
    transition: transform .06s ease, background .12s ease;
    display:flex; justify-content:space-between; gap:10px; align-items:center;
    min-height: 54px;
  }
  .choice:active{transform: translateY(1px)}
  .choice b{font-size:14px}
  .choice small{color:var(--muted); font-size:11px}
  .choice.correct{border-color: rgba(56,217,150,.55); background: rgba(56,217,150,.14)}
  .choice.wrong{border-color: rgba(255,92,122,.55); background: rgba(255,92,122,.14)}

  .typingRow{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  input[type="text"]{
    /* ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãŒè¦‹ãˆã‚„ã™ã„ã‚ˆã†ã«å¤§ãã‚ */
    width: min(560px, 100%);
    padding: 16px 14px;
    border-radius: 14px;
    border:1px solid var(--line);
    background: rgba(0,0,0,.25);
    color:var(--ink);
    outline:none;
    font-size: 24px;
    line-height: 1.15;
    letter-spacing: .02em;
    font-weight: 700;
    caret-color: var(--good);
  }
  input[type="text"]::placeholder{color: rgba(169,179,214,.8)}

  @media (max-width:520px){
    input[type="text"]{ font-size: 22px; padding: 16px 14px; }
  }

  /* Typing progress (per-letter feedback) */
  .typeMirror{margin-top:10px; display:flex; gap:6px; align-items:center; flex-wrap:wrap}
  .typeMirror .label{font-size:12px; color:var(--muted); margin-right:2px}
  .typeMirror .tile{
    min-width: 30px;
    padding: 10px 10px;
    border-radius: 12px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.04);
    text-align:center;
    font-size: 22px;
    line-height: 1;
    font-weight: 900;
    letter-spacing: .02em;
    user-select:none;
  }
  .typeMirror .tile.pending{opacity:.55}
  .typeMirror .tile.correct{border-color: rgba(56,217,150,.55); background: rgba(56,217,150,.16)}
  .typeMirror .tile.wrong{border-color: rgba(255,92,122,.55); background: rgba(255,92,122,.14)}
  input[type="text"].ok{border-color: rgba(56,217,150,.55); box-shadow: 0 0 0 3px rgba(56,217,150,.14)}
  input[type="text"].ng{border-color: rgba(255,92,122,.55); box-shadow: 0 0 0 3px rgba(255,92,122,.12)}

  .hint{
    font-size:12px; color:var(--muted); line-height:1.35;
  }

  /* Overlay */
  .overlay{
    position:fixed; inset:0; display:none;
    background: rgba(0,0,0,.55);
    backdrop-filter: blur(8px);
    z-index:50;
    padding: 16px;
    overflow:auto;
    -webkit-overflow-scrolling: touch;
  }
  .overlay .panel{
    max-width: 920px; margin: 0 auto;
    background: rgba(18,26,51,.95);
    border:1px solid var(--line);
    border-radius: 22px;
    box-shadow: 0 18px 44px rgba(0,0,0,.45);
    overflow:hidden;

    /* allow tall content like results tables to be scrollable */
    max-height: calc(100vh - 32px);
    max-height: calc(100dvh - 32px);
    display:flex;
    flex-direction:column;
  }
  .overlay .panel .hd{padding: 14px; border-bottom:1px solid var(--line); display:flex; justify-content:space-between; align-items:center; gap:10px}
  .overlay .panel .bd{padding:14px; overflow:auto; flex:1 1 auto; -webkit-overflow-scrolling:touch}
  
  .grid2{display:grid; gap:12px; grid-template-columns: 1fr 1fr}
  @media (max-width:760px){.grid2{grid-template-columns:1fr}}
  textarea{
    width:100%;
    min-height: 140px;
    padding: 10px;
    border-radius: 14px;
    border:1px solid var(--line);
    background: rgba(0,0,0,.25);
    color:var(--ink);
    outline:none;
    resize: vertical;
  }
  .tiny{font-size:11px; color:var(--muted)}
  table{width:100%; border-collapse:collapse; font-size:13px}
  .thbtn{
    appearance:none; -webkit-appearance:none;
    border:0; background:transparent; color:inherit;
    font:inherit; font-weight:600;
    padding:6px 8px; margin:-6px -8px;
    border-radius:10px;
    cursor:pointer;
  }
  .thbtn:hover{background:rgba(255,255,255,.08)}
  .thbtn:active{transform:translateY(1px)}
  .thbtn .arrow{opacity:.8; margin-left:4px; font-size:11px}

  th,td{padding:8px 6px; border-bottom:1px solid var(--line); vertical-align:top}
  th{text-align:left; color:var(--muted); font-weight:600}
  .right{text-align:right}
  .good{color:var(--good)}
  .bad{color:var(--bad)}


  /* --- Mobile layout fixes: prevent "can't play because header eats screen" --- */
  html, body{ max-width: 100%; overflow-x:hidden; }
  @media (max-width: 520px){
    header{ padding: 10px 12px; }
    header .title h1{ font-size: 18px; line-height:1.15; }
    header .title .tag{ font-size: 12px; padding: 6px 10px; }
    .hud{ gap:8px; flex-wrap:wrap; }
    .pill{ padding:10px 12px; }
    #btnStart{ padding: 12px 14px; }
    main{ padding: 10px; }
    .card .hd{ padding: 10px 12px; }
    .card .bd{ padding: 10px 12px; }
  }

  /* Let the stage grow to fill the remaining visible viewport (JS will fine-tune) */
  #stageWrap{ height: min(60dvh, 560px); }


  /* --- Mobile: give more room to the stage by compacting controls/answers --- */
  #answerArea{ margin-top: 8px; }
  @media (max-width: 520px){
    /* Put 4 choices in 2 columns to save vertical space */
    .answers{ grid-template-columns: 1fr 1fr !important; gap: 8px; }
    .choice{ padding: 10px 10px; min-height: 46px; border-radius: 14px; }
    .choice b{ font-size: 13px; }
    .choice small{ font-size: 10px; }
    /* Compact the pills and small buttons row */
    .pill{ padding: 8px 10px; }
    .btn.small{ padding: 8px 10px; }
  }
  @media (max-width: 340px){
    .answers{ grid-template-columns: 1fr !important; }
  }


  /* --- Mobile: shrink the top header panel to free the stage area --- */
  @media (max-width: 520px){
    header{ padding-top: calc(8px + var(--sat)); padding-left:10px; padding-right:10px; padding-bottom:8px; }
    header .row{ gap:8px; }
    header .title h1{ font-size: 16px; line-height:1.12; }
    header .title .tag{ display:none; } /* tag line takes vertical space */
    #btnHelp, #btnSettings{ padding: 6px 10px; font-size: 12px; border-radius: 12px; }
    /* Less vertical gaps between header blocks */
    header .row[style*="margin-top"]{ margin-top: 6px !important; }

    /* Pills become compact */
    .pill{ padding: 6px 8px; border-radius: 14px; }
    .pill strong{ font-size: 11px; }
    .pill span{ font-size: 11px; }
    .pill.meter .bar{ height: 8px; }
    .pill.meter{ gap:6px; }

    /* Hide CSV pill on small screens (still accessible via settings) */
    #pillCsv{ display:none; }

    /* Reduce button sizes */
    #btnStart, #btnPause, #btnRestart{ padding: 8px 10px; font-size: 12px; border-radius: 14px; }

    /* Hide pause/restart while disabled to keep header short before starting */
    #btnPause:disabled, #btnRestart:disabled{ display:none; }
  }

  /* --- Answer top bar: keep Mode/Target + Speak/Skip tidy on mobile --- */
  .answerTop{display:flex; justify-content:space-between; gap:10px; align-items:center; flex-wrap:wrap}
  .answerLeft,.answerRight{display:flex; gap:8px; align-items:center}
  .answerLeft{min-width:0}
  .answerLeft .pill span{max-width: 220px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
  @media (max-width:520px){
    .answerTop{flex-wrap:nowrap}
    .answerLeft{gap:6px}
    .answerLeft .pill{padding:6px 8px; border-radius:14px}
    .answerLeft .pill strong{font-size:11px}
    .answerLeft .pill span{font-size:11px; max-width: 140px}
    .answerRight{gap:6px}
    #btnSpeak, #btnSkip{
      min-width:44px;
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 18px; /* big icon */
      line-height: 1;
    }
  }

</style>
</head>
<body>
<header>
  <div class="row" style="justify-content:space-between">
    <div class="title">
      <h1>å˜èªå¡¾ã‚¢ãƒ¼ã‚±ãƒ¼ãƒ‰ï¼ˆè½ä¸‹ãƒ¯ãƒ¼ãƒ‰ï¼‰</h1>
      <span class="tag">CSVå¯¾å¿œ / ã‚³ãƒ³ãƒœ / ãƒœã‚¹å¾©ç¿’</span>
    </div>
    <div class="row">
      <button id="btnHelp" class="btn small ghost">ä½¿ã„æ–¹</button>
      <button id="btnSettings" class="btn small">è¨­å®š</button>
    </div>
  </div>

  <div class="row" style="margin-top:10px; justify-content:space-between">
    <div class="hud">
      <div class="pill"><strong>ã‚¹ã‚³ã‚¢</strong><span id="hudScore" class="mono">0</span></div>
      <div class="pill"><strong>ã‚³ãƒ³ãƒœ</strong><span id="hudCombo" class="mono">0</span></div>
      <div class="pill"><strong>å‘½ä¸­</strong><span id="hudAcc" class="mono">0%</span></div>
      <div class="pill" id="pillCsv"><strong>CSV</strong><span id="hudCsv" class="mono">å†…è”µã‚µãƒ³ãƒ—ãƒ«</span></div>
    </div>
    <div class="hud">
      <div class="pill meter">
        <strong>HP</strong>
        <div class="bar hp"><i id="hpBar"></i></div>
        <span id="hpTxt" class="mono">5/5</span>
      </div>
      <div class="pill meter" id="bossHud" style="display:none">
        <strong>ãƒœã‚¹</strong>
        <div class="bar boss"><i id="bossBar"></i></div>
        <span id="bossTxt" class="mono">0/0</span>
      </div>
      <button id="btnStart" class="btn primary">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      <button id="btnPause" class="btn" disabled>ä¸€æ™‚åœæ­¢</button>
      <button id="btnRestart" class="btn danger" disabled>ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>
  </div>
</header>

<main>
  <section class="card">
    <div class="hd">
      <h2>ã‚¹ãƒ†ãƒ¼ã‚¸</h2>
      <div class="row">
        <span class="tiny">æ“ä½œ: <span class="kbd">1</span><span class="kbd">2</span><span class="kbd">3</span><span class="kbd">4</span> / <span class="kbd">Space</span> ä¸€æ™‚åœæ­¢ / <span class="kbd">R</span> ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</span>
      </div>
    </div>
    <div class="bd">
      <div id="stageWrap">
        <div id="stage">
          <div class="laneHint"></div>
        </div>
      </div>

      <div id="answerArea">
        <div class="row answerTop">
          <div class="row answerLeft">
            <span class="pill"><strong>ãƒ¢ãƒ¼ãƒ‰</strong><span id="hudMode" class="mono">4æŠ</span></span>
            <span class="pill"><strong>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ</strong><span id="hudTarget" class="mono">-</span></span>
          </div>
          <div class="row answerRight">
            <button id="btnSpeak" class="btn small" disabled title="ç™ºéŸ³">ğŸ”Š</button>
            <button id="btnSkip" class="btn small" disabled title="ã‚¹ã‚­ãƒƒãƒ—">â­</button>
          </div>
        </div>

        <div id="choicePanel">
          <div class="answers">
            <button class="choice" data-i="0"><b id="c0">-</b><small class="mono">1</small></button>
            <button class="choice" data-i="1"><b id="c1">-</b><small class="mono">2</small></button>
            <button class="choice" data-i="2"><b id="c2">-</b><small class="mono">3</small></button>
            <button class="choice" data-i="3"><b id="c3">-</b><small class="mono">4</small></button>
          </div>
                    <p class="hint" style="margin:10px 0 0">
            è½ã¡ã¦ãã‚‹å˜èªã«å¯¾ã—ã¦ã€æ­£ã—ã„æ„å‘³ã‚’é¸ã¶ã¨æ’ƒã¡è½ã¨ã›ã¾ã™ã€‚æ­£è§£ã§ã‚³ãƒ³ãƒœUPã€ãƒŸã‚¹ã§HPæ¸›ã€‚<br>
            é–“é•ãˆãŸå˜èªã¯ã€Œå¾©ç¿’èªã€ã¨ã—ã¦ãƒ—ãƒ¼ãƒ«ã•ã‚Œã€ä¸€å®šæ•°é€²ã‚€ã¨<strong>ãƒœã‚¹</strong>ã¨ã—ã¦å†ç™»å ´ã—ã¾ã™ ğŸ‰ğŸ“š
          </p>
        </div>

        <div id="typingPanel" style="display:none">
          <div class="typingRow">
            <input id="typeInput" type="text" placeholder="ã“ã“ã«è‹±å˜èªã‚’å…¥åŠ›ã—ã¦Enterï¼ˆä¾‹: adventureï¼‰" autocomplete="off" spellcheck="false" />
            <button id="btnEnter" class="btn primary">Enter</button>
            <button id="btnReveal" class="btn">ç­”ãˆã‚’è¦‹ã‚‹</button>
          </div>
          <div id="typeMirror" class="typeMirror mono" aria-live="polite"></div>
          <p class="hint" style="margin:10px 0 0">
            ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€è½ã¡ã¦ãã‚‹ã€Œæ—¥æœ¬èªã€ã‚’è¦‹ã¦è‹±å˜èªã‚’å…¥åŠ›ã—ã¾ã™ã€‚<br>
            å…¥åŠ›ã¯å¤§æ–‡å­—å°æ–‡å­—ç„¡è¦–ã€‚ç©ºç™½ã®é•ã„ã‚‚ã‚ã‚‹ã®ã§ã€CSVå´ã®è¡¨è¨˜ã«åˆã‚ã›ã‚‹ã¨å®‰å®šã—ã¾ã™ã€‚
          </p>
        </div>
      </div>
    </div>
  </section>

  <aside class="card">
    <div class="hd">
      <h2>ãƒ­ãƒ¼ãƒ‰ & çµæœ</h2>
      <div class="row">
        <button id="btnOpenLoader" class="btn small">CSVèª­ã¿è¾¼ã¿</button>
        <button id="btnOpenResults" class="btn small">çµæœ</button>
      </div>
    </div>
    <div class="bd">
      <div class="row" style="gap:8px; align-items:flex-start">
        <div class="pill"><strong>å˜èªæ•°</strong><span id="hudCount" class="mono">0</span></div>
        <div class="pill"><strong>å¾©ç¿’èª</strong><span id="hudWrongPool" class="mono">0</span></div>
        <div class="pill"><strong>æœ€é«˜</strong><span id="hudBest" class="mono">0</span></div>
      </div>

      <div style="margin-top:10px" class="hint">
        <div><strong>å¯¾å¿œCSVä¾‹</strong></div>
        <div class="mono tiny">en,ja,level,lang</div>
        <div class="mono tiny">adjustment,èª¿æ•´,5,en</div>
        <div class="mono tiny">gratitude,æ„Ÿè¬,4,en</div>
        <div class="mono tiny">â€¦ï¼ˆlevelã¯ç©ºã§ã‚‚OKï¼‰</div>
        <div style="margin-top:8px"><strong>ãƒ’ãƒ³ãƒˆ</strong>ï¼šå˜èªå¡¾ã®CSVã‚’ãã®ã¾ã¾å…¥ã‚Œã¦OKã€‚jaåˆ—ãŒãªã„å ´åˆã¯ã€enåˆ—ã ã‘ã§ã‚‚éŠã¹ã¾ã™ï¼ˆæ„å‘³ã¯ãƒ€ãƒŸãƒ¼è¡¨ç¤ºï¼‰ã€‚</div>
      </div>

      <div style="margin-top:12px; border-top:1px dashed var(--line); padding-top:12px">
        <div class="row" style="justify-content:space-between">
          <div><strong>ã‚²ãƒ¼ãƒ ã®é›£æ˜“åº¦</strong></div>
          <span class="tiny muted">ã‚¹ãƒ”ãƒ¼ãƒ‰ã¯ãƒ—ãƒ¬ã‚¤ä¸­ã«è‡ªå‹•å¤‰åŒ–</span>
        </div>
        <div class="row" style="margin-top:8px; gap:10px">
          <label class="pill"><strong>HP</strong><span><input id="optHp" type="number" min="1" max="20" value="5" style="width:70px"></span></label>
          <label class="pill"><strong>åŒæ™‚è½ä¸‹</strong><span><input id="optMaxEnemies" type="number" min="1" max="10" value="3" style="width:70px"></span></label>
        </div>
        <div class="row" style="margin-top:8px; gap:10px; flex-wrap:wrap">
          <label class="pill"><strong>ã‚¹ãƒ”ãƒ¼ãƒ‰</strong>
            <span class="mono">
              <input id="optSpeedRange" type="range" min="40" max="360" value="120" style="width:180px; vertical-align:middle">
              <input id="optSpeedNum" type="number" min="40" max="360" value="120" style="width:84px; margin-left:8px"> <span class="tiny muted">px/ç§’</span>
            </span>
          </label>
        </div>
        <div class="row" style="margin-top:8px; gap:10px">
          <label class="pill"><strong>ãƒ¢ãƒ¼ãƒ‰</strong>
            <span>
              <select id="optMode" style="padding:8px; border-radius:12px; border:1px solid var(--line); background: rgba(0,0,0,.25); color:var(--ink)">
                <option value="choice" selected>4æŠ</option>
                <option value="typing">ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ï¼ˆjaâ†’enï¼‰</option>
              </select>
            </span>
          </label>
        </div>
        <div class="row" style="margin-top:8px; gap:10px; flex-wrap:wrap">
          <label class="pill"><strong>4æŠã®å‡ºé¡Œ</strong>
            <span>
              <select id="optChoiceDir" style="padding:8px; border-radius:12px; border:1px solid var(--line); background: rgba(0,0,0,.25); color:var(--ink)">
                <option value="en2ja" selected>è‹±èª â†’ æ—¥æœ¬èªï¼ˆé¸æŠï¼‰</option>
                <option value="ja2en">æ—¥æœ¬èª â†’ è‹±èªï¼ˆé¸æŠï¼‰</option>
              </select>
            </span>
          </label>
        </div>

      </div>
    </div>
  </aside>
</main>

<!-- Overlays -->
<div id="ovHelp" class="overlay">
  <div class="panel">
    <div class="hd">
      <strong>ä½¿ã„æ–¹</strong>
      <button class="btn small" data-close="ovHelp">é–‰ã˜ã‚‹</button>
    </div>
    <div class="bd">
      <div class="grid2">
        <div class="card" style="box-shadow:none">
          <div class="hd"><h2>åŸºæœ¬</h2></div>
          <div class="bd">
            <ul style="margin:0; padding-left:18px; line-height:1.6">
              <li><strong>ã‚¹ã‚¿ãƒ¼ãƒˆ</strong>ã§é–‹å§‹ã€‚å˜èªãŒä¸Šã‹ã‚‰è½ã¡ã¦ãã¾ã™ã€‚</li>
              <li><strong>4æŠ</strong>ï¼šæ­£ã—ã„æ„å‘³ã‚’ã‚¯ãƒªãƒƒã‚¯ or <span class="kbd">1</span>ã€œ<span class="kbd">4</span>ã§é¸æŠã€‚</li>
              <li><strong>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°</strong>ï¼šè½ã¡ã¦ãã‚‹æ—¥æœ¬èªã‚’è¦‹ã¦è‹±å˜èªã‚’å…¥åŠ›ã— <span class="kbd">Enter</span>ã€‚</li>
              <li>æ­£è§£ã§ã‚³ãƒ³ãƒœãŒä¼¸ã³ã€ãƒŸã‚¹ã§HPãŒå‰Šã‚Œã¾ã™ã€‚</li>
              <li>é–“é•ãˆãŸå˜èªã¯å¾©ç¿’èªãƒ—ãƒ¼ãƒ«ã¸ã€‚ä¸€å®šæ•°é€²ã‚€ã¨<strong>ãƒœã‚¹æˆ¦</strong>ãŒç™ºç”Ÿã€‚</li>
            </ul>
          </div>
        </div>
        <div class="card" style="box-shadow:none">
          <div class="hd"><h2>CSVèª­ã¿è¾¼ã¿</h2></div>
          <div class="bd">
            <ul style="margin:0; padding-left:18px; line-height:1.6">
              <li>ãƒ˜ãƒƒãƒ€ãƒ¼æ¨å¥¨ï¼š<span class="mono">en,ja,level,lang</span></li>
              <li><span class="mono">lang</span> ã¯ <span class="mono">en</span>/<span class="mono">ja</span>/<span class="mono">fr</span>â€¦ãªã©ï¼ˆéŸ³å£°ã®è¨€èªãƒ’ãƒ³ãƒˆï¼‰ã€‚</li>
              <li><span class="mono">level</span> ã¯ 1ã€œ5 ãªã©ã€‚ç©ºã§ã‚‚OKã€‚</li>
              <li>åŒºåˆ‡ã‚Šã¯ã‚«ãƒ³ãƒã€‚Excelã§ä½œã‚‹ãªã‚‰UTF-8ä¿å­˜ãŒãŠã™ã™ã‚ã€‚</li>
            </ul>
            <div class="tiny muted" style="margin-top:8px">
              â€» æ—¢å­˜ã®å˜èªå¡¾CSVã«åˆ—ãŒå¢—ãˆã¦ã„ã¦ã‚‚å¤§ä¸ˆå¤«ã€‚<strong>en ã¨ ja</strong> ãŒå–ã‚Œã‚Œã°éŠã¹ã¾ã™ã€‚
            </div>
          </div>
        </div>
      </div>
      <div style="margin-top:12px" class="tiny muted">
        è£æŠ€: <span class="kbd">Space</span> ã§ä¸€æ™‚åœæ­¢ã€‚<span class="kbd">R</span> ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã€‚
      </div>
    </div>
  </div>
</div>

<div id="ovLoader" class="overlay">
  <div class="panel">
    <div class="hd">
      <strong>CSVèª­ã¿è¾¼ã¿</strong>
      <button class="btn small" data-close="ovLoader">é–‰ã˜ã‚‹</button>
    </div>
    <div class="bd">
      <div class="grid2">
        <div>
          <div class="row" style="gap:10px; align-items:center">
            <input id="fileCsv" type="file" accept=".csv,text/csv" />
            <button id="btnLoadFile" class="btn primary">èª­ã¿è¾¼ã¿</button>
          </div>
          <div class="tiny muted" style="margin-top:8px">
            ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã«èª­ã¿è¾¼ã¿ã¾ã™ï¼ˆå¤–éƒ¨é€ä¿¡ãªã—ï¼‰ã€‚
          </div>
          <div style="margin-top:10px">
            <div><strong>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå…ˆé ­10è¡Œï¼‰</strong></div>
            <pre id="csvPreview" class="mono" style="white-space:pre-wrap; background: rgba(0,0,0,.25); border:1px solid var(--line); border-radius:14px; padding:10px; max-height:220px; overflow:auto; margin:8px 0 0;"></pre>
          </div>
        </div>
        <div>
          <div><strong>æ‰‹è²¼ã‚Šã§ã‚‚OK</strong>ï¼ˆCSVã‚’ã‚³ãƒ”ãƒšï¼‰</div>
          <textarea id="csvText" placeholder="en,ja,level,lang&#10;gratitude,æ„Ÿè¬,4,en"></textarea>
          <div class="row" style="justify-content:flex-end; margin-top:10px">
            <button id="btnLoadText" class="btn primary">è²¼ã‚Šä»˜ã‘ã‚’èª­ã¿è¾¼ã¿</button>
          </div>
          <div class="tiny muted">
            Excelã‹ã‚‰ã®è²¼ã‚Šä»˜ã‘ã§ã‚¿ãƒ–åŒºåˆ‡ã‚Šã«ãªã‚‹å ´åˆã¯ã€è¨­å®šã§åŒºåˆ‡ã‚Šã‚’å¤‰æ›´ã—ã¦ã‚‚OKï¼ˆå³ä¸Šè¨­å®šï¼‰ã€‚
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="ovSettings" class="overlay">
  <div class="panel">
    <div class="hd">
      <strong>è¨­å®š</strong>
      <button class="btn small" data-close="ovSettings">é–‰ã˜ã‚‹</button>
    </div>
    <div class="bd">
      <div class="grid2">
        <div>
          <div class="card" style="box-shadow:none">
            <div class="hd"><h2>ã‚²ãƒ¼ãƒ </h2></div>
            <div class="bd">
              <div class="row" style="gap:10px; flex-wrap:wrap">
                <label class="pill"><strong>è½ä¸‹é€Ÿåº¦</strong>
                  <span>
                    <input id="setBaseSpeed" type="number" min="40" max="360" value="120" style="width:90px"> <span class="tiny muted">px/ç§’</span>
                  </span>
                </label>
                <label class="pill"><strong>å‡ºç¾é–“éš”</strong>
                  <span>
                    <input id="setSpawnMs" type="number" min="300" max="3000" value="900" style="width:90px"> <span class="tiny muted">ms</span>
                  </span>
                </label>
              </div>
              <div class="row" style="gap:10px; margin-top:10px">
                <label class="pill"><strong>åŒºåˆ‡ã‚Šæ–‡å­—</strong>
                  <span>
                    <select id="setDelimiter" style="padding:8px; border-radius:12px; border:1px solid var(--line); background: rgba(0,0,0,.25); color:var(--ink)">
                      <option value=",">ã‚«ãƒ³ãƒ (,)</option>
                      <option value="tab">ã‚¿ãƒ–</option>
                      <option value=";">ã‚»ãƒŸã‚³ãƒ­ãƒ³ (;)</option>
                    </select>
                  </span>
                </label>
                <label class="pill"><strong>ãƒœã‚¹é »åº¦</strong>
                  <span>
                    <input id="setBossEvery" type="number" min="5" max="50" value="15" style="width:90px"> <span class="tiny muted">æ’ƒç ´ã”ã¨</span>
                  </span>
                </label>
              </div>
              <div class="row" style="gap:10px; margin-top:10px">
                <label class="pill"><strong>ãƒœã‚¹HP</strong>
                  <span>
                    <input id="setBossHp" type="number" min="1" max="20" value="6" style="width:90px">
                  </span>
                </label>
                <label class="pill"><strong>å¾©ç¿’èªã®é‡ã¿</strong>
                  <span>
                    <input id="setWrongWeight" type="number" min="1" max="10" value="3" style="width:90px">
                  </span>
                </label>
              </div>
              <div class="tiny muted" style="margin-top:10px">
                â€» å¾©ç¿’èªã®é‡ã¿ï¼šé–“é•ãˆãŸå˜èªãŒå†å‡ºç¾ã—ã‚„ã™ããªã‚‹å€ç‡ã§ã™ã€‚
              </div>
            </div>
          </div>
        </div>

        <div>
          <div class="card" style="box-shadow:none">
            <div class="hd"><h2>éŸ³å£°ï¼ˆSpeechSynthesisï¼‰</h2></div>
            <div class="bd">
              <div class="row" style="gap:10px; flex-wrap:wrap">
                <label class="pill"><strong>è‡ªå‹•ç™ºéŸ³</strong>
                  <span><input id="setAutoSpeak" type="checkbox" checked></span>
                </label>
                <label class="pill"><strong>ç™ºéŸ³å¯¾è±¡</strong>
                  <span>
                    <select id="setSpeakWhich" style="padding:8px; border-radius:12px; border:1px solid var(--line); background: rgba(0,0,0,.25); color:var(--ink)">
                      <option value="en" selected>è‹±èªï¼ˆenåˆ—ï¼‰</option>
                      <option value="ja">æ—¥æœ¬èªï¼ˆjaåˆ—ï¼‰</option>
                    </select>
                  </span>
                </label>
              </div>

              <div class="row" style="gap:10px; margin-top:10px; flex-wrap:wrap">
                <label class="pill"><strong>éŸ³å£°è¨€èª</strong>
                  <span>
                    <select id="setVoiceLang" style="padding:8px; border-radius:12px; border:1px solid var(--line); background: rgba(0,0,0,.25); color:var(--ink)">
                      <option value="auto" selected>è‡ªå‹•ï¼ˆlangåˆ—ã‚’å„ªå…ˆï¼‰</option>
                      <option value="en">è‹±èª (en)</option>
                      <option value="ja">æ—¥æœ¬èª (ja)</option>
                      <option value="fr">ãƒ•ãƒ©ãƒ³ã‚¹èª (fr)</option>
                      <option value="de">ãƒ‰ã‚¤ãƒ„èª (de)</option>
                      <option value="es">ã‚¹ãƒšã‚¤ãƒ³èª (es)</option>
                      <option value="it">ã‚¤ã‚¿ãƒªã‚¢èª (it)</option>
                      <option value="ko">éŸ“å›½èª (ko)</option>
                      <option value="zh">ä¸­å›½èª (zh)</option>
                    </select>
                  </span>
                </label>

                <label class="pill"><strong>é€Ÿåº¦</strong>
                  <span><input id="setRate" type="number" min="0.5" max="1.5" step="0.1" value="1.0" style="width:90px"></span>
                </label>
                <label class="pill"><strong>é«˜ã•</strong>
                  <span><input id="setPitch" type="number" min="0.5" max="1.5" step="0.1" value="1.0" style="width:90px"></span>
                </label>
              </div>

              <div class="row" style="justify-content:flex-end; margin-top:12px">
                <button id="btnApplySettings" class="btn primary">é©ç”¨</button>
              </div>
              <div class="tiny muted" style="margin-top:10px">
                â€» ãƒ–ãƒ©ã‚¦ã‚¶ã‚„ç«¯æœ«ã«ã‚ˆã£ã¦éŸ³å£°ã®è³ªãŒå¤‰ã‚ã‚Šã¾ã™ï¼ˆç‰¹ã«ã‚¹ãƒãƒ›ã¯ç«¯æœ«å†…ã®éŸ³å£°ã‚¨ãƒ³ã‚¸ãƒ³ã®å½±éŸ¿ãŒå¤§ãã„ã§ã™ï¼‰ã€‚
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="row" style="justify-content:space-between; margin-top:12px">
        <button id="btnResetBest" class="btn danger">æœ€é«˜ã‚¹ã‚³ã‚¢ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
        <span class="tiny muted">è¨­å®šã¯ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ã•ã‚Œã¾ã™ï¼ˆlocalStorageï¼‰</span>
      </div>
    </div>
  </div>
</div>

<div id="ovResults" class="overlay">
  <div class="panel">
    <div class="hd">
      <strong>çµæœ</strong>
      <button class="btn small" data-close="ovResults">é–‰ã˜ã‚‹</button>
    </div>
    <div class="bd">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <div class="pill"><strong>ä»Šå›</strong><span id="resScore" class="mono">0</span></div>
          <div class="pill"><strong>å‘½ä¸­</strong><span id="resAcc" class="mono">0%</span></div>
          <div class="pill"><strong>ãƒ™ã‚¹ãƒˆ</strong><span id="resBest" class="mono">0</span></div>
        </div>
        <div class="row" style="gap:8px">
          <button id="btnExportWrong" class="btn">å¾©ç¿’èªã‚’CSVã§å‡ºåŠ›</button>
          <button id="btnClearStats" class="btn danger">ä»Šå›ã®å±¥æ­´ã‚’ã‚¯ãƒªã‚¢</button>
        </div>
      </div>

      <div class="row" style="justify-content:space-between">
        <div class="row">
          <div class="pill"><strong>ä»Šå›é †ä½</strong><span id="resRank" class="mono">-</span></div>
          <div class="pill"><strong>ä»Šæ—¥é †ä½</strong><span id="resRankDay" class="mono">-</span></div>
          <div class="pill"><strong>å¯¾è±¡</strong><span id="resRankCsv" class="mono">-</span></div>
        </div>
        <div class="row" style="gap:8px">
          <button id="btnOpenRank" class="btn">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
        </div>
      </div>
      <div style="overflow:auto; border:1px solid var(--line); border-radius:16px">
        <table>
          <thead>
            <tr>
              <th>å˜èª</th>
              <th>æ„å‘³</th>
              <th class="right">æ­£</th>
              <th class="right">èª¤</th>
              <th class="right">æœ€çµ‚</th>
            </tr>
          </thead>
          <tbody id="resTable"></tbody>
        </table>
      </div>
      <div class="tiny muted" style="margin-top:10px">
        ã€Œå¾©ç¿’èªã‚’CSVã§å‡ºåŠ›ã€ã¯ã€é–“é•ãˆãŸå˜èªã‚’ <span class="mono">en,ja,level,lang</span> ã§åãå‡ºã—ã¾ã™ã€‚å˜èªå¡¾ã«æˆ»ã—ã¦å†æŠ•å…¥ã§ãã¾ã™ ğŸ”
      </div>
    </div>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
(() => {
  "use strict";


  // ----------------------------
  // Mobile: fit stage to visible viewport (prevents "game screen is hidden")
  // ----------------------------
  const fitStageToViewport = () => {
    const header = document.querySelector("header");
    const stageWrap = document.querySelector("#stageWrap");
    if(!header || !stageWrap) return;

    // visualViewport is best on mobile (accounts for URL bar / keyboard)
    const vv = window.visualViewport;
    const vh = vv ? vv.height : window.innerHeight;

    const headerH = header.getBoundingClientRect().height;

    // Estimated non-stage vertical space inside the main card below stage (answer UI etc.)
    // Keep it conservative so the stage stays comfortably visible.
    const other = 190;

    let avail = vh - headerH - other;

    // Clamp stage height: not too tiny, not too huge
    const h = Math.max(280, Math.min(680, Math.floor(avail)));

    // Apply if it makes sense
    if(Number.isFinite(h) && h > 0){
      stageWrap.style.height = h + "px";
    }
  };

  // Run on load + when viewport changes (URL bar, rotate, keyboard)
  window.addEventListener("resize", fitStageToViewport, {passive:true});
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", fitStageToViewport, {passive:true});
    window.visualViewport.addEventListener("scroll", fitStageToViewport, {passive:true});
  }
  fitStageToViewport();


  // ----------------------------
  // Small helpers
  // ----------------------------
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => [...root.querySelectorAll(sel)];
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();
  const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];
  const uniq = (arr) => [...new Set(arr)];
  const norm = (s) => (s ?? "").toString().trim();
  const normKey = (s) => norm(s).toLowerCase().replace(/\s+/g, " ").trim();
  const safeInt = (x, d=0) => {
    const n = parseInt(x, 10);
    return Number.isFinite(n) ? n : d;
  };

  // ----------------------------
  // DOM
  // ----------------------------
  const stage = $("#stage");
  const hudScore = $("#hudScore");
  const hudCombo = $("#hudCombo");
  const hudAcc = $("#hudAcc");
  const hudCsv = $("#hudCsv");
  let baseCsvLabel = "å†…è”µã‚µãƒ³ãƒ—ãƒ«";
  const hudCount = $("#hudCount");
  const hudWrongPool = $("#hudWrongPool");
  const hudBest = $("#hudBest");
  const hudMode = $("#hudMode");
  const hudTarget = $("#hudTarget");

  const hpBar = $("#hpBar");
  const hpTxt = $("#hpTxt");

  const bossHud = $("#bossHud");
  const bossBar = $("#bossBar");
  const bossTxt = $("#bossTxt");

  const btnStart = $("#btnStart");
  const btnPause = $("#btnPause");
  const btnRestart = $("#btnRestart");
  const btnSkip = $("#btnSkip");
  const btnSpeak = $("#btnSpeak");

  const choicePanel = $("#choicePanel");
  const typingPanel = $("#typingPanel");
  const typeInput = $("#typeInput");
  const typeMirror = $("#typeMirror");
  const btnEnter = $("#btnEnter");
  const btnReveal = $("#btnReveal");

  const cEls = [$("#c0"), $("#c1"), $("#c2"), $("#c3")];
  const choiceBtns = $$(".choice");

  // overlays
  const ovHelp = $("#ovHelp");
  const ovLoader = $("#ovLoader");
  const ovSettings = $("#ovSettings");
  const ovResults = $("#ovResults");

  // loader
  const fileCsv = $("#fileCsv");
  const btnLoadFile = $("#btnLoadFile");
  const btnLoadText = $("#btnLoadText");
  const csvText = $("#csvText");
  const csvPreview = $("#csvPreview");

  // settings quick (aside)
  const optHp = $("#optHp");
  const optMaxEnemies = $("#optMaxEnemies");
  const optMode = $("#optMode");
  const optChoiceDir = $("#optChoiceDir");
  const optSpeedRange = $("#optSpeedRange");
  const optSpeedNum = $("#optSpeedNum");

  // settings overlay
  const setBaseSpeed = $("#setBaseSpeed");
  const setSpawnMs = $("#setSpawnMs");
  const setDelimiter = $("#setDelimiter");
  const setBossEvery = $("#setBossEvery");
  const setBossHp = $("#setBossHp");
  const setWrongWeight = $("#setWrongWeight");

  const setAutoSpeak = $("#setAutoSpeak");
  const setSpeakWhich = $("#setSpeakWhich");
  const setVoiceLang = $("#setVoiceLang");
  const setRate = $("#setRate");
  const setPitch = $("#setPitch");

  const btnApplySettings = $("#btnApplySettings");
  const btnResetBest = $("#btnResetBest");

  // results
  const btnExportWrong = $("#btnExportWrong");
  const btnClearStats = $("#btnClearStats");
  const resScore = $("#resScore");
  const resAcc = $("#resAcc");
  const resBest = $("#resBest");
  const resTable = $("#resTable");
  const resRank = $("#resRank");
  const resRankDay = $("#resRankDay");
  const resRankCsv = $("#resRankCsv");
  const btnOpenRank = $("#btnOpenRank");

  // rank overlay
  const ovRank = $("#ovRank");
  const tabRankSession = $("#tabRankSession");
  const tabRankWords = $("#tabRankWords");
  const tabRankDaily = $("#tabRankDaily");
  const rankScope = $("#rankScope");
  const rankLabel = $("#rankLabel");
  const rankLabel2 = $("#rankLabel2");
  const rankLabel3 = $("#rankLabel3");
  const rankSessionTable = $("#rankSessionTable");
  const rankWordTable = $("#rankWordTable");
  const rankDailyTable = $("#rankDailyTable");
  const rankViewSession = $("#rankViewSession");
  const rankViewWords = $("#rankViewWords");
  const rankViewDaily = $("#rankViewDaily");

  // top buttons
  $("#btnHelp").addEventListener("click", () => openOverlay(ovHelp));
  $("#btnSettings").addEventListener("click", () => openOverlay(ovSettings));
  $("#btnOpenLoader").addEventListener("click", () => openOverlay(ovLoader));
  $("#btnOpenResults").addEventListener("click", () => { refreshResults(); openOverlay(ovResults); });
  btnOpenRank.addEventListener("click", () => { refreshRankUI(); openOverlay(ovRank); });

  $$(".overlay [data-close]").forEach(btn => {
    btn.addEventListener("click", (e) => closeOverlay($("#" + e.currentTarget.dataset.close)));
  });
  $$(".overlay").forEach(ov => {
    ov.addEventListener("click", (e) => { if(e.target === ov) closeOverlay(ov); });
  });

  function openOverlay(ov){ ov.style.display = "block"; }
  function closeOverlay(ov){ ov.style.display = "none"; }

  // ----------------------------
  // Data model
  // ----------------------------
  const DEFAULT_WORDS = [
    ["gratitude","æ„Ÿè¬",4,"en"],
    ["adjustment","èª¿æ•´",5,"en"],
    ["endurance","æŒä¹…åŠ›",4,"en"],
    ["recruitment","æ¡ç”¨",4,"en"],
    ["invasion","ä¾µç•¥",4,"en"],
    ["suite","ã‚¹ã‚¤ãƒ¼ãƒˆï¼ˆéƒ¨å±‹ï¼‰ï¼ä¸€å¼",4,"en"],
    ["addressee","å®›å…ˆäºº",5,"en"],
    ["opening","é–‹å§‹ï¼é–‹å£éƒ¨",2,"en"],
    ["tune-up","èª¿æ•´ï¼ç‚¹æ¤œ",5,"en"],
    ["pharmacist","è–¬å‰¤å¸«",4,"en"],
    ["uniformity","å‡ä¸€æ€§",5,"en"],
    ["conception","æ¦‚å¿µï¼å—èƒ",5,"en"],
    ["orbit","è»Œé“",4,"en"],
    ["workload","ä»•äº‹é‡",3,"en"],
    ["closure","é–‰é–ï¼çµ‚çµ",4,"en"],
    ["duplicate","è¤‡è£½ã™ã‚‹ï¼é‡è¤‡",3,"en"],
    ["inferiority","åŠ£ç­‰",5,"en"],
    ["machinist","æ©Ÿæ¢°å·¥",5,"en"],
    ["removal","é™¤å»",3,"en"],
    ["shield","ç›¾ï¼å®ˆã‚‹",3,"en"],
    ["attendant","ä¿‚å“¡",4,"en"],
    ["chill","å¯’æ°—ï¼å†·ãˆã‚‹",4,"en"],
    ["steadily","ç€å®Ÿã«",3,"en"],
    ["roughly","ãŠãŠã‚ˆã",2,"en"],
    ["beneficial","æœ‰ç›Šãª",3,"en"],
    ["urgently","ç·Šæ€¥ã«",3,"en"],
    ["evidently","æ˜ã‚‰ã‹ã«",4,"en"],
    ["accidentally","å¶ç„¶ã«",2,"en"],
    ["eventually","çµå±€ã¯",2,"en"],
    ["barely","ã‹ã‚ã†ã˜ã¦",3,"en"],
    ["brilliantly","è¦‹äº‹ã«",4,"en"],
    ["specifically","å…·ä½“çš„ã«",3,"en"],
    ["indefinitely","ç„¡æœŸé™ã«",5,"en"],
    ["sincere","èª å®Ÿãª",3,"en"],
    ["scarce","ä¸è¶³ã—ãŸ",4,"en"],
    ["defensive","é˜²å¾¡ã®",3,"en"],
    ["illustrated","æŒ¿çµµå…¥ã‚Šã®ï¼èª¬æ˜ã—ãŸ",4,"en"],
    ["passage","ä¸€ç¯€ï¼é€šè·¯",3,"en"],
    ["remote","é éš”ã®",2,"en"],
    ["modest","æ§ãˆã‚ãª",2,"en"],
  ];

  // Typing is hard with long words. This pack is intentionally short (3-4 letters).
  const EASY_WORDS = [
    ["cat","çŒ«",1,"en"], ["dog","çŠ¬",1,"en"], ["sun","å¤ªé™½",1,"en"], ["sky","ç©º",1,"en"],
    ["book","æœ¬",1,"en"], ["desk","æœº",1,"en"], ["milk","ç‰›ä¹³",1,"en"], ["cake","ã‚±ãƒ¼ã‚­",1,"en"],
    ["bird","é³¥",1,"en"], ["fish","é­š",1,"en"], ["rain","é›¨",1,"en"], ["snow","é›ª",1,"en"],
    ["tree","æœ¨",1,"en"], ["road","é“",1,"en"], ["hand","æ‰‹",1,"en"], ["foot","è¶³",1,"en"],
    ["slow","é…ã„",1,"en"], ["fast","é€Ÿã„",1,"en"], ["good","è‰¯ã„",1,"en"], ["cool","ã‹ã£ã“ã„ã„ï¼æ¶¼ã—ã„",1,"en"],
    ["warm","æš–ã‹ã„",1,"en"], ["hard","é›£ã—ã„ï¼ç¡¬ã„",1,"en"], ["easy","ç°¡å˜ãª",1,"en"], ["kind","è¦ªåˆ‡ãª",1,"en"],
    ["play","éŠã¶",1,"en"], ["walk","æ­©ã",1,"en"], ["sing","æ­Œã†",1,"en"], ["jump","è·³ã¶",1,"en"],
    ["open","é–‹ã‘ã‚‹",1,"en"], ["close","é–‰ã‚ã‚‹",1,"en"], ["help","åŠ©ã‘ã‚‹",1,"en"], ["give","ä¸ãˆã‚‹",1,"en"],
    ["take","å–ã‚‹",1,"en"], ["come","æ¥ã‚‹",1,"en"], ["go","è¡Œã",1,"en"], ["read","èª­ã‚€",1,"en"],
    ["write","æ›¸ã",1,"en"], ["talk","è©±ã™",1,"en"], ["hear","èã",1,"en"], ["look","è¦‹ã‚‹",1,"en"]
  ];


  // current vocabulary list
  /** @type {{en:string, ja:string, level:number|null, lang:string|null}[]} */
  let vocab = DEFAULT_WORDS.map(([en,ja,lv,lang]) => ({en,ja,level:lv ?? null, lang: lang ?? null}));


  // In typing mode we use a simplified pool (short words) so it feels playable.
  /** @type {{en:string, ja:string, level:number|null, lang:string|null}[]} */
  let typingVocab = [];
  /** @type {{en:string, ja:string, level:number|null, lang:string|null}[]} */
  let activeVocab = vocab;
  updateDatasetId();

  function onlyLettersLen(en){
    const letters = (en ?? "").toString().replace(/[^a-z]/ig, "");
    return letters.length;
  }

  function buildTypingVocab(){
    // Prefer the user's CSV words, but only 3-4 letter ones.
    const short = vocab.filter(v => {
      const L = onlyLettersLen(v.en);
      return L >= 3 && L <= 4;
    });

    // If not enough, add built-in EASY_WORDS (still 3-4 letters).
    const easy = EASY_WORDS.map(([en,ja,lv,lang]) => ({en,ja,level:lv ?? null, lang: lang ?? null}));

    const merged = [];
    const seen = new Set();
    const pushUniq = (it) => {
      const k = (it.en||"").toLowerCase().trim();
      if(!k || seen.has(k)) return;
      seen.add(k);
      merged.push(it);
    };

    short.forEach(pushUniq);
    easy.forEach(pushUniq);

    return merged.length ? merged : easy;
  }

  function setActiveVocabForMode(){
    if(mode === "typing"){
      typingVocab = buildTypingVocab();
      activeVocab = typingVocab;
      hudCsv.textContent = baseCsvLabel + " / ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç°¡å˜èª";
      hudCount.textContent = String(activeVocab.length);
    }else{
      activeVocab = vocab;
      hudCsv.textContent = baseCsvLabel;
      hudCount.textContent = String(activeVocab.length);
    }
  }

  // stats per word
  /** key -> {en,ja,level,lang, correct:number, wrong:number, last:string} */
  let stats = {};  // in-memory for this run
  // wrong pool: key -> wrongCount (for spawn weighting and boss list)
  let wrongPool = {};

  // settings stored
  const LS_KEY = "tangojuku_arcade_v1";
  const defaultSettings = {
    baseSpeed: 120,      // px/s
    spawnMs: 900,
    delimiter: ",",
    bossEvery: 15,       // kills
    bossHp: 6,
    wrongWeight: 3,      // spawn weight multiplier per wrongCount
    autoSpeak: true,
    speakWhich: "en",    // en or ja
    voiceLang: "auto",
    rate: 1.0,
    pitch: 1.0,
    choiceDirection: "en2ja",  // 4æŠ: en->ja or ja->en
    bestScore: 0
  };
  let settings = loadSettings();

  function loadSettings(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return {...defaultSettings};
      const obj = JSON.parse(raw);
      return {...defaultSettings, ...obj};
    }catch{
      return {...defaultSettings};
    }
  }
  function saveSettings(){
    localStorage.setItem(LS_KEY, JSON.stringify(settings));
    hudBest.textContent = settings.bestScore|0;
  }

  // apply settings to UI
  function syncSettingsUI(){
    setBaseSpeed.value = settings.baseSpeed;
    // aside quick speed controls
    if(typeof syncSpeedUIFromSettings === "function"){ syncSpeedUIFromSettings(); }
    setSpawnMs.value = settings.spawnMs;
    setDelimiter.value = settings.delimiter === "\t" ? "tab" : settings.delimiter;
    setBossEvery.value = settings.bossEvery;
    setBossHp.value = settings.bossHp;
    setWrongWeight.value = settings.wrongWeight;

    setAutoSpeak.checked = !!settings.autoSpeak;
    setSpeakWhich.value = settings.speakWhich;
    setVoiceLang.value = settings.voiceLang;
    setRate.value = settings.rate;
    setPitch.value = settings.pitch;

    // choice direction
    if(optChoiceDir) optChoiceDir.value = settings.choiceDirection || "en2ja";

    hudBest.textContent = settings.bestScore|0;
  }


  // ----------------------------
  // Ranking persistence (per CSV + all CSV)
  // ----------------------------
  const LS_RANK_KEY = "tangojuku_arcade_rank_v1";

  function fnv1a(str){
    let h = 0x811c9dc5;
    for(let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = (h + ((h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))) >>> 0;
    }
    return ("0000000" + h.toString(16)).slice(-8);
  }

  function datasetFingerprint(){
    // hash en+ja; sample first 1200 lines to keep fast
    const parts = [];
    const take = Math.min(vocab.length, 1200);
    for(let i=0;i<take;i++){
      const it = vocab[i];
      parts.push((it.en||"").toLowerCase().trim() + "|" + (it.ja||"").trim());
    }
    return fnv1a(parts.join("\n"));
  }

  var datasetId = "";
  function updateDatasetId(){
    datasetId = datasetFingerprint();
  }

  function loadRankStore(){
    try{
      const raw = localStorage.getItem(LS_RANK_KEY);
      if(!raw) return {datasets:{}, allSessions:[], allWord:{}};
      const obj = JSON.parse(raw);
      if(!obj.datasets) obj.datasets = {};
      if(!Array.isArray(obj.allSessions)) obj.allSessions = [];
      if(!obj.allWord) obj.allWord = {};
      return obj;
    }catch{
      return {datasets:{}, allSessions:[], allWord:{}};
    }
  }
  function saveRankStore(store){
    try{ localStorage.setItem(LS_RANK_KEY, JSON.stringify(store)); }catch{}
  }

  function getDs(store, id){
    if(!store.datasets[id]){
      store.datasets[id] = { label: baseCsvLabel, sessions:[], word:{} };
    }
    store.datasets[id].label = baseCsvLabel;
    return store.datasets[id];
  }

  function todayKey(ts){
    const d = new Date(ts);
    const y = d.getFullYear();
    const m = ("0"+(d.getMonth()+1)).slice(-2);
    const dd = ("0"+d.getDate()).slice(-2);
    return `${y}-${m}-${dd}`;
  }

  function computeRank(list, sc){
    let higher = 0;
    for(const s of list){
      if((s.score|0) > (sc|0)) higher++;
    }
    return higher + 1;
  }

  function recordSession(){
    updateDatasetId();
    const store = loadRankStore();
    const ds = getDs(store, datasetId);

    const acc = seen ? Math.round((hit/seen)*100) : 0;
    const rec = {
      ts: Date.now(),
      score: score|0,
      acc,
      mode,
      dir: settings.choiceDirection || "en2ja",
      words: (activeVocab?.length || vocab.length || 0),
      label: baseCsvLabel
    };

    ds.sessions.unshift(rec);
    if(ds.sessions.length > 200) ds.sessions.length = 200;

    store.allSessions.unshift({...rec, datasetId});
    if(store.allSessions.length > 400) store.allSessions.length = 400;

    for(const k of Object.keys(stats)){
      const st = stats[k];

      if(!ds.word[k]) ds.word[k] = {en:st.en, ja:st.ja, correct:0, wrong:0};
      ds.word[k].correct += (st.correct|0);
      ds.word[k].wrong += (st.wrong|0);
      ds.word[k].en = st.en; ds.word[k].ja = st.ja;

      if(!store.allWord[k]) store.allWord[k] = {en:st.en, ja:st.ja, correct:0, wrong:0};
      store.allWord[k].correct += (st.correct|0);
      store.allWord[k].wrong += (st.wrong|0);
      store.allWord[k].en = st.en; store.allWord[k].ja = st.ja;
    }

    saveRankStore(store);
  }

  function getRankSource(store){
    const scope = (rankScope?.value || "csv");
    if(scope === "all"){
      return { label:"å…¨CSV", sessions: store.allSessions || [], word: store.allWord || {} };
    }
    updateDatasetId();
    const ds = getDs(store, datasetId);
    return { label: ds.label || "ã“ã®CSV", sessions: ds.sessions || [], word: ds.word || {} };
  }

  function showRankTab(which){
    rankViewSession.style.display = (which==="session") ? "" : "none";
    rankViewWords.style.display = (which==="words") ? "" : "none";
    rankViewDaily.style.display = (which==="daily") ? "" : "none";

    tabRankSession.classList.toggle("primary", which==="session");
    tabRankWords.classList.toggle("primary", which==="words");
    tabRankDaily.classList.toggle("primary", which==="daily");
  }

  tabRankSession?.addEventListener("click", () => { showRankTab("session"); refreshRankUI(); });
  tabRankWords?.addEventListener("click", () => { showRankTab("words"); refreshRankUI(); });
  tabRankDaily?.addEventListener("click", () => { showRankTab("daily"); refreshRankUI(); });
  rankScope?.addEventListener("change", () => refreshRankUI());
  // --- word ranking sort (clickable headers) ---
  let rankWordSort = { key: "wrong", dir: "desc" }; // default: èª¤ãŒå¤šã„é †

  function setRankWordSort(key){
    if(rankWordSort.key === key){
      rankWordSort.dir = (rankWordSort.dir === "desc") ? "asc" : "desc";
    }else{
      rankWordSort.key = key;
      rankWordSort.dir = (key === "acc") ? "asc" : "desc"; // æ­£è§£ç‡ã¯ä½ã„é †ãŒãƒ‡ãƒ•ã‚©
    }
    refreshRankUI();
  }

  function updateRankWordSortUI(){
    const hint = document.getElementById("rankWordSortHint");
    const aC = document.getElementById("sortArrowCorrect");
    const aW = document.getElementById("sortArrowWrong");
    const aA = document.getElementById("sortArrowAcc");
    if(aC) aC.textContent = "";
    if(aW) aW.textContent = "";
    if(aA) aA.textContent = "";

    const arrow = (rankWordSort.dir === "desc") ? "â–¼" : "â–²";
    if(rankWordSort.key === "correct" && aC) aC.textContent = arrow;
    if(rankWordSort.key === "wrong" && aW) aW.textContent = arrow;
    if(rankWordSort.key === "acc" && aA) aA.textContent = arrow;

    if(hint){
      if(rankWordSort.key === "wrong") hint.textContent = `èª¤ãŒå¤šã„é †ï¼ˆèª¤${arrow} â†’ æ­£è§£ç‡ â†’ ABCï¼‰`;
      else if(rankWordSort.key === "correct") hint.textContent = `æ­£ãŒå¤šã„é †ï¼ˆæ­£${arrow} â†’ æ­£è§£ç‡ â†’ ABCï¼‰`;
      else hint.textContent = `æ­£è§£ç‡é †ï¼ˆæ­£è§£ç‡${arrow} â†’ èª¤ â†’ ABCï¼‰`;
    }
  }

  // attach once DOM is ready
  document.addEventListener("click", (e)=>{
    const btn = e.target?.closest?.(".rankSortBtn");
    if(!btn) return;
    const key = btn.getAttribute("data-sort");
    if(key) setRankWordSort(key);
  });


  function fmtDate(ts){
    const d = new Date(ts);
    const Y = d.getFullYear();
    const M = ("0"+(d.getMonth()+1)).slice(-2);
    const D = ("0"+d.getDate()).slice(-2);
    const h = ("0"+d.getHours()).slice(-2);
    const m = ("0"+d.getMinutes()).slice(-2);
    return `${Y}/${M}/${D} ${h}:${m}`;
  }

  function refreshRankUI(){
    const store = loadRankStore();
    const src = getRankSource(store);

    const labelText = (rankScope.value === "all") ? "å…¨CSV" : (src.label || "ã“ã®CSV");
    rankLabel.textContent = labelText;
    rankLabel2.textContent = labelText;
    rankLabel3.textContent = labelText;

    updateRankWordSortUI();


    const sessions = (src.sessions || []);
    const sorted = [...sessions].sort((a,b)=> (b.score|0)-(a.score|0) || (b.ts|0)-(a.ts|0));

    let lastScore = null, currentRank = 0, idx = 0;
    const rankRows = [];
    for(const rec of sorted.slice(0, 30)){
      idx++;
      if(lastScore === null || (rec.score|0) !== lastScore){
        currentRank = idx;
        lastScore = (rec.score|0);
      }
      rankRows.push(`
        <tr>
          <td class="right mono">${currentRank}</td>
          <td class="right mono">${rec.score|0}</td>
          <td class="right mono">${(rec.acc|0)}%</td>
          <td>${escapeHtml(rec.mode === "typing" ? "ã‚¿ã‚¤ãƒ”ãƒ³ã‚°" : "4æŠ")}</td>
          <td class="mono">${escapeHtml(fmtDate(rec.ts))}</td>
        </tr>
      `);
    }
    rankSessionTable.innerHTML = rankRows.join("") || `<tr><td colspan="5" class="muted">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>`;

    const words = Object.values(src.word || {});
    words.sort((a,b)=>{
      const at = (a.correct|0) + (a.wrong|0);
      const bt = (b.correct|0) + (b.wrong|0);
      const aAcc = at ? (a.correct/at) : 1;
      const bAcc = bt ? (b.correct/bt) : 1;

      const key = rankWordSort.key;
      const dir = rankWordSort.dir;

      const cmpNum = (x,y)=> (dir==="desc") ? (y-x) : (x-y);

      if(key === "wrong"){
        const aw = a.wrong|0, bw = b.wrong|0;
        if(bw !== aw) return cmpNum(aw,bw);
        if(aAcc !== bAcc) return aAcc - bAcc; // tiebreak: lower acc first
        return (a.en||"").localeCompare(b.en||"");
      }
      if(key === "correct"){
        const ac = a.correct|0, bc = b.correct|0;
        if(bc !== ac) return cmpNum(ac,bc);
        if(aAcc !== bAcc) return aAcc - bAcc;
        return (a.en||"").localeCompare(b.en||"");
      }
      // acc
      if(aAcc !== bAcc) return cmpNum(aAcc,bAcc);
      const aw = a.wrong|0, bw = b.wrong|0;
      if(bw !== aw) return cmpNum(aw,bw); // secondary
      return (a.en||"").localeCompare(b.en||"");
    });
    const wRows = words.slice(0, 40).map(w=>{
      const total = (w.correct|0)+(w.wrong|0);
      const accP = total ? Math.round((w.correct/total)*100) : 0;
      return `
        <tr>
          <td class="mono">${escapeHtml(w.en||"")}</td>
          <td>${escapeHtml(w.ja||"")}</td>
          <td class="right good mono">${w.correct|0}</td>
          <td class="right bad mono">${w.wrong|0}</td>
          <td class="right mono">${accP}%</td>
        </tr>
      `;
    });
    rankWordTable.innerHTML = wRows.join("") || `<tr><td colspan="5" class="muted">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>`;

    const byDay = {};
    for(const rec of sessions){
      const k = todayKey(rec.ts);
      if(!byDay[k]) byDay[k] = {best: rec.score|0, count:1};
      else{
        byDay[k].count += 1;
        if((rec.score|0) > byDay[k].best) byDay[k].best = rec.score|0;
      }
    }
    const days = Object.entries(byDay).sort((a,b)=> b[0].localeCompare(a[0]));
    const dRows = days.slice(0, 60).map(([d,info])=>`
      <tr>
        <td class="mono">${escapeHtml(d)}</td>
        <td class="right mono">${info.best|0}</td>
        <td class="right mono">${info.count|0}</td>
      </tr>
    `);
    rankDailyTable.innerHTML = dRows.join("") || `<tr><td colspan="3" class="muted">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>`;
  }

  // ----------------------------
  // CSV parsing
  // ----------------------------
  function splitLine(line, delim){
    // minimal CSV splitter supporting quotes
    const out = [];
    let cur = "";
    let inQ = false;
    for(let i=0;i<line.length;i++){
      const ch = line[i];
      if(ch === '"'){
        if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      }else if(!inQ && ch === delim){
        out.push(cur); cur="";
      }else{
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  function parseCSV(text){
    const t = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n");
    const lines = t.split("\n").filter(l => l.trim().length>0);
    if(!lines.length) return {rows:[], header:[]};

    const delim = settings.delimiter;
    const sep = (delim === "\t") ? "\t" : delim;

    // detect header by checking if first row contains "en" or "ja"
    const first = splitLine(lines[0], sep).map(s => norm(s).replace(/^"|"$/g,""));
    const hasHeader = first.some(x => ["en","ja","level","lang","tts"].includes(x.toLowerCase()));

    let header = [];
    let startIdx = 0;
    if(hasHeader){
      header = first.map(x => x.toLowerCase());
      startIdx = 1;
    }else{
      // fallback header: assume en,ja,level,lang...
      header = ["en","ja","level","lang"];
      startIdx = 0;
    }

    const rows = [];
    for(let i=startIdx;i<lines.length;i++){
      const cols = splitLine(lines[i], sep).map(s => norm(s).replace(/^"|"$/g,""));
      if(cols.every(c => c==="")) continue;
      const obj = {};
      for(let j=0;j<cols.length;j++){
        obj[header[j] ?? ("col"+j)] = cols[j];
      }
      rows.push(obj);
    }
    return {rows, header};
  }

  function loadVocabFromText(text, nameLabel="èª­ã¿è¾¼ã¿CSV"){
    const {rows} = parseCSV(text);
    const list = [];
    for(const r of rows){
      const en = norm(r.en ?? r.word ?? r.english ?? r.e ?? r.col0);
      const ja = norm(r.ja ?? r.jp ?? r.japanese ?? r.meaning ?? r.m ?? r.col1);
      const lang = norm(r.lang ?? r.language ?? r.l ?? r.col3) || null;
      const lvRaw = norm(r.level ?? r.lv ?? r.rank ?? r.col2);
      const level = lvRaw ? safeInt(lvRaw, null) : null;

      if(!en && !ja) continue;

      // allow en-only or ja-only lines
      list.push({
        en: en || "(no-en)",
        ja: ja || "(æ„å‘³æœªè¨­å®š)",
        level: (level !== null && Number.isFinite(level)) ? level : null,
        lang
      });
    }

    if(!list.length){
      alert("CSVã‹ã‚‰å˜èªãŒèª­ã¿å–ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ˜ãƒƒãƒ€ãƒ¼ãŒ en,ja,level,lang ã«ãªã£ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
      return;
    }
    vocab = list;
    resetRunStats();
    baseCsvLabel = nameLabel;
    hudCsv.textContent = baseCsvLabel;
    updateDatasetId();
    hudCount.textContent = vocab.length.toString();
    closeOverlay(ovLoader);
    toast(`èª­ã¿è¾¼ã¿OK: ${vocab.length}èª`);
  }

  btnLoadText.addEventListener("click", () => {
    const t = csvText.value.trim();
    if(!t){ alert("è²¼ã‚Šä»˜ã‘æ¬„ãŒç©ºã§ã™"); return; }
    csvPreview.textContent = t.split(/\r?\n/).slice(0,10).join("\n");
    loadVocabFromText(t, "è²¼ã‚Šä»˜ã‘CSV");
  });

  btnLoadFile.addEventListener("click", async () => {
    const f = fileCsv.files?.[0];
    if(!f){ alert("CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„"); return; }
    const text = await f.text();
    csvPreview.textContent = text.split(/\r?\n/).slice(0,10).join("\n");
    loadVocabFromText(text, f.name);
  });

  // ----------------------------
  // Speech
  // ----------------------------
  let voices = [];
  function refreshVoices(){
    voices = speechSynthesis?.getVoices?.() ?? [];
  }
  if("speechSynthesis" in window){
    refreshVoices();
    // some browsers load voices async
    window.speechSynthesis.onvoiceschanged = refreshVoices;
  }

  function hasJapaneseChars(s){
  // Hiragana / Katakana / Kanji (incl. CJK extensions commonly used)
  return /[\u3040-\u30FF\u3400-\u9FFF\uF900-\uFAFF]/.test(s);
}
function hasLatinLetters(s){
  return /[A-Za-z]/.test(s);
}
function inferLangFromText(text, langHint){
  const t = norm(text);
  const hint = (langHint || "").toLowerCase();

  // 1) Text itself wins: if it's Latin letters and NOT Japanese, treat as English.
  if(t && !hasJapaneseChars(t) && hasLatinLetters(t)) return "en";
  if(t && hasJapaneseChars(t)) return "ja";

  // 2) Otherwise follow hint (CSV lang)
  if(hint.startsWith("en")) return "en";
  if(hint.startsWith("ja")) return "ja";
  if(hint.startsWith("fr")) return "fr";
  if(hint.startsWith("de")) return "de";
  if(hint.startsWith("es")) return "es";
  if(hint.startsWith("it")) return "it";
  if(hint.startsWith("ko")) return "ko";
  if(hint.startsWith("zh")) return "zh";

  // 3) Last resort: prefer English (prevents "Japanese-style" reading by default)
  return "en";
}

function pickVoice(langCode){
  if(!voices.length) return null;

  // If user forced a language in settings, respect it.
  let want = (settings.voiceLang === "auto") ? (langCode || "en") : settings.voiceLang;
  want = (want || "en").toLowerCase();

  const map = {
    en: [/^en(-|_)?/i],
    ja: [/^ja(-|_)?/i],
    fr: [/^fr(-|_)?/i],
    de: [/^de(-|_)?/i],
    es: [/^es(-|_)?/i],
    it: [/^it(-|_)?/i],
    ko: [/^ko(-|_)?/i],
    zh: [/^zh(-|_)?/i]
  };

  const pats = map[want] || [];
  if(pats.length){
    const v = voices.find(v => pats.some(p => p.test(v.lang)));
    if(v) return v;
  }

  // Fallback order matters: prefer English first, then Japanese.
  const enV = voices.find(v => /^en(-|_)?/i.test(v.lang));
  if(enV) return enV;

  const jaV = voices.find(v => /^ja(-|_)?/i.test(v.lang));
  if(jaV) return jaV;

  return voices[0];
}

function speak(text, langHint){
  if(!("speechSynthesis" in window)) return;
  const t = norm(text);
  if(!t) return;

  // Decide language: text > hint > default(en)
  const langCode = inferLangFromText(t, langHint);

  try{
    speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(t);
    u.rate = clamp(Number(settings.rate)||1.0, 0.5, 1.5);
    u.pitch = clamp(Number(settings.pitch)||1.0, 0.5, 1.5);

    // Give the engine a strong language hint (prevents "æ—¥æœ¬èªã£ã½ã„è‹±èª" in many browsers)
    u.lang = (langCode === "en") ? "en-US"
          : (langCode === "ja") ? "ja-JP"
          : langCode;

    const v = pickVoice(langCode);
    if(v) u.voice = v;

    speechSynthesis.speak(u);
  }catch{}
}


function getPromptSide(){
  // Prevent spoilers: speak the *prompt* side, not the answer.
  if(mode === "typing") return "ja"; // typing prompt is Japanese
  const d = settings.choiceDirection || "en2ja";
  return (d === "ja2en") ? "ja" : "en";
}
function getPromptText(it){
  const side = getPromptSide();
  return (side === "ja") ? (it.ja || it.en || "") : (it.en || it.ja || "");
}

  // ----------------------------
  // Game state
  // ----------------------------
  let running = false;
  let paused = false;

  let hpMax = 5;
  let hp = 5;

  let score = 0;
  let combo = 0;
  let seen = 0;
  let hit = 0;
  let kills = 0;

  let mode = "choice"; // choice or typing

  // Effective pacing (changes automatically in typing mode)
  let effectiveBaseSpeed = 120;   // px/s actually used for enemies
  let effectiveSpawnMs = 900;     // ms between spawns actually used

  const enemies = []; // active falling objects
  let spawnTimer = 0;


  // Avoid showing the same word repeatedly.
  // We keep a short history of recently used keys and also avoid duplicates currently on screen.
  const recentPickKeys = []; // newest first
  function recentPickLimit(){
    // keep around ~20% of pool, clamped
    const n = activeVocab?.length || 0
    const lim = Math.floor(n * 0.20)
    return clamp(lim, 8, 20)
  }
  function rememberPickKey(k){
    if(!k) return
    // move to front (dedupe)
    const idx = recentPickKeys.indexOf(k)
    if(idx >= 0) recentPickKeys.splice(idx, 1)
    recentPickKeys.unshift(k)
    const lim = recentPickLimit()
    if(recentPickKeys.length > lim) recentPickKeys.length = lim
  }
  let lastTick = now();

  let currentTarget = null; // the enemy the player is answering against
  let currentChoices = [];  // array of vocab items (or strings)
  let correctIndex = 0;

  // boss mode
  let bossActive = false;
  let bossHpMax = 0;
  let bossHp = 0;
  let bossKeyList = []; // keys of wrongPool eligible
  let bossEnemy = null;

  const LANES = 4; // 4 columns
  function laneX(lane){
    const rect = stage.getBoundingClientRect();
    const w = rect.width;
    const step = w / LANES;
    return (lane + 0.5) * step;
  }

  function makeKey(item){
    // key should remain stable for stats even if ja missing
    return normKey(item.en) + "||" + normKey(item.ja);
  }

  function ensureStat(item){
    const k = makeKey(item);
    if(!stats[k]){
      stats[k] = { en:item.en, ja:item.ja, level:item.level, lang:item.lang, correct:0, wrong:0, last:"-" };
    }
    return stats[k];
  }

  function addWrong(item){
    const k = makeKey(item);
    wrongPool[k] = (wrongPool[k] || 0) + 1;
    hudWrongPool.textContent = Object.keys(wrongPool).length.toString();
  }

  function decWrong(k){
    if(!wrongPool[k]) return;
    wrongPool[k] -= 1;
    if(wrongPool[k] <= 0) delete wrongPool[k];
    hudWrongPool.textContent = Object.keys(wrongPool).length.toString();
  }

  function recomputeEffectivePacing(){
    // Base values from settings (player-tuned)
    let bs = settings.baseSpeed;
    let sp = settings.spawnMs;

    // Typing needs more breathing room: slower fall + bigger gaps
    if(mode === "typing"){
      bs = Math.max(40, Math.round(bs * 0.60));     // 40% slower
      sp = Math.min(3000, Math.round(sp * 2.40));   // 2.4x spacing
    }

    effectiveBaseSpeed = bs;
    effectiveSpawnMs = sp;

    // sync the aside speed controls to the *base* speed (what user edits)
    // (the effective speed is derived automatically for typing)
  }

  function resetRunStats(){
    stats = {};
    wrongPool = {};
    hudWrongPool.textContent = "0";
    hudCount.textContent = vocab.length.toString();
    // leave best score
  }

  // ----------------------------
  // Spawning
  // ----------------------------

  function weightedPickVocab(){
    if(!activeVocab.length) return null;

    const onScreen = new Set(enemies.filter(e => e && e.alive).map(e => makeKey(e.item)));
    const recentSet = new Set(recentPickKeys);

    const strict = [];  // avoid recent + avoid on-screen
    const relaxed = []; // avoid on-screen only

    for(const it of activeVocab){
      const k = makeKey(it);
      const wc = wrongPool[k] || 0;
      const extra = wc * (settings.wrongWeight|0);
      const w = 1 + Math.max(0, extra);

      for(let i=0;i<w;i++){
        relaxed.push(it);
        if(!onScreen.has(k) && !recentSet.has(k)) strict.push(it);
      }
    }

    // Prefer strict list to keep spacing between repeats.
    let base = strict.length ? strict : relaxed.filter(it => !onScreen.has(makeKey(it)));
    if(!base.length) base = relaxed; // final fallback

    const chosen = pick(base);
    if(chosen) rememberPickKey(makeKey(chosen));
    return chosen;
  }

  function makeEnemy(item, isBoss=false){
    const div = document.createElement("div");
    div.className = "enemy" + (isBoss ? " boss" : "");
    const lv = item.level ? `Lv${item.level}` : "Lv-";

    // Show ONLY the prompt on the falling card (no spoiler translation).
    // typing: ja prompt, answer is en typed.
    // 4-choice: direction can be switched.
    const isTyping = (mode === "typing");
    const dir = settings.choiceDirection || "en2ja";
    const promptText = isTyping
      ? (item.ja || "(æ„å‘³æœªè¨­å®š)")
      : (dir === "ja2en" ? (item.ja || "(æ„å‘³æœªè¨­å®š)") : (item.en || "(no-en)"));

    const labelTop = promptText;

    // Sub line: never show the translation/answer.
    let sub = "";
    if(isTyping){
      const L = onlyLettersLen(item.en);
      sub = L ? `æ–‡å­—æ•°: ${L}` : "è‹±å˜èªã‚’å…¥åŠ›";
    }else{
      sub = "";
    }
    div.innerHTML = `
      <div class="top">
        <div class="w">${escapeHtml(labelTop)}</div>
        <div class="lv">${escapeHtml(lv)}${isBoss ? " / BOSS" : ""}</div>
      </div>
      <div class="sub">${escapeHtml(sub)}</div>
    `;
    stage.appendChild(div);

    const lane = Math.floor(Math.random()*LANES);
    const rect = stage.getBoundingClientRect();

    // --- Clamp X so the card never gets cut off on narrow screens ---
    // Because .enemy uses transform: translate(-50%, -50%), x is the CENTER.
    const cardW = div.getBoundingClientRect().width || 160;
    const half = cardW / 2;
    const pad = 8; // inner padding from the stage edge

    let minX = half + pad;
    let maxX = rect.width - half - pad;
    if(minX > maxX){
      minX = maxX = rect.width / 2;
    }

    const x = clamp(laneX(lane), minX, maxX);
    const y = -10;

    const speed = isBoss ? Math.max(60, effectiveBaseSpeed * 0.85) : effectiveBaseSpeed + Math.min(160, combo*4);
    const id = cryptoRandomId();

    return {
      id,
      item,
      isBoss,
      lane,
      x,
      y,
      speed,
      el: div,
      alive: true
    };
  }

  function cryptoRandomId(){
    if(window.crypto?.getRandomValues){
      const a = new Uint32Array(2);
      crypto.getRandomValues(a);
      return a[0].toString(16) + a[1].toString(16);
    }
    return Math.random().toString(16).slice(2);
  }

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
  }

  function spawnIfNeeded(dt){
    const maxEnemies = clamp(safeInt(optMaxEnemies.value, 3), 1, 10);

    // boss trigger
    if(!bossActive && !paused && running && Object.keys(wrongPool).length>0 && kills>0 && (kills % settings.bossEvery === 0)){
      startBoss();
      return;
    }

    if(bossActive) return; // only boss on screen in boss mode

    spawnTimer -= dt;
    if(spawnTimer <= 0 && enemies.length < maxEnemies){
      spawnTimer = effectiveSpawnMs;
      const item = weightedPickVocab();
      if(!item) return;
      const e = makeEnemy(item, false);
      enemies.push(e);
      // set target if none
      if(!currentTarget) chooseTarget();
      applyTargetHighlight();
    }
  }


  function applyTargetHighlight(){
    // clear
    for(const e of enemies){
      if(e?.el) e.el.classList.toggle('target', currentTarget && e.id === currentTarget.id);
    }
    if(bossEnemy?.el) bossEnemy.el.classList.toggle('target', currentTarget && bossEnemy && currentTarget.id === bossEnemy.id);
  }

  function chooseTarget(){
    // choose the lowest enemy (closest to bottom) as target
    if(bossActive){
      currentTarget = bossEnemy;
      applyTargetHighlight();
      renderQuestionFor(currentTarget.item);
      return;
    }
    const alive = enemies.filter(e => e.alive);
    if(!alive.length){
      currentTarget = null;
      applyTargetHighlight();
      hudTarget.textContent = "-";
      setChoicesDisabled(true);
      if(mode === "typing" && typeMirror){ typeMirror.innerHTML = ""; typeInput.classList.remove("ok","ng"); }
      return;
    }
    alive.sort((a,b) => b.y - a.y);
    currentTarget = alive[0];
    applyTargetHighlight();
    renderQuestionFor(currentTarget.item);
  }

  function renderQuestionFor(item){
    if(!item) return;

    const dir = settings.choiceDirection || "en2ja";
    const isTyping = (mode === "typing");

    // Prompt depends on mode/direction
    const promptText = isTyping
      ? (item.ja || "(æ„å‘³æœªè¨­å®š)")
      : (dir === "ja2en" ? (item.ja || "(æ„å‘³æœªè¨­å®š)") : (item.en || "(no-en)"));

    hudTarget.textContent = promptText;

    btnSpeak.disabled = false;
    btnSkip.disabled = false;

    if(mode === "choice"){
      const correct = item;

      // Build distractors from active pool
      const pool = activeVocab.filter(v => makeKey(v) !== makeKey(correct));
      const sameLv = correct.level ? pool.filter(v => v.level === correct.level) : [];
      const source = sameLv.length >= 3 ? sameLv : pool;

      const picks = [];
      while(picks.length < 3 && source.length){
        const d = pick(source);
        const dk = makeKey(d);
        if(picks.some(x => makeKey(x) === dk)) continue;
        picks.push(d);
      }
      while(picks.length < 3 && pool.length){
        const d = pick(pool);
        const dk = makeKey(d);
        if(picks.some(x => makeKey(x) === dk)) continue;
        picks.push(d);
      }

      currentChoices = [correct, ...picks];

      // shuffle
      for(let i=currentChoices.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [currentChoices[i], currentChoices[j]] = [currentChoices[j], currentChoices[i]];
      }

      correctIndex = currentChoices.findIndex(v => makeKey(v) === makeKey(correct));

      // Render choice labels based on direction (answers are opposite side)
      cEls.forEach((el, i) => {
        const it = currentChoices[i];
        const ansText = (dir === "ja2en") ? (it.en || "(no-en)") : (it.ja || "(æ„å‘³æœªè¨­å®š)");
        el.textContent = ansText;
      });

      resetChoiceStyles();
      setChoicesDisabled(false);
    }else{
      // typing mode: re-enable input/buttons in case they were disabled while waiting for next spawn
      setChoicesDisabled(false);
      typeInput.value = "";
      updateTypeMirror();
      typeInput.focus({preventScroll:true});
    }

    // optionally speak (no audio for Japanese prompts to avoid spoilers / unnecessary audio)
    if(settings.autoSpeak && getPromptSide() !== "ja"){
      const text = getPromptText(item);
      speak(text, item.lang);
    }
  }

  function resetChoiceStyles(){
    choiceBtns.forEach(b => b.classList.remove("correct","wrong"));
  }
  function setChoicesDisabled(disabled){
    choiceBtns.forEach(b => b.disabled = disabled);
    btnSkip.disabled = disabled;
    btnSpeak.disabled = disabled;
    btnEnter.disabled = disabled;
    btnReveal.disabled = disabled;
    typeInput.disabled = disabled;
  }

  // ----------------------------
  // Boss
  // ----------------------------
  function startBoss(){
    bossActive = true;
    bossKeyList = Object.keys(wrongPool);
    const firstKey = pick(bossKeyList);
    const item = activeVocab.find(v => makeKey(v) === firstKey) || activeVocab.find(v => makeKey(v) === bossKeyList[0]) || weightedPickVocab();
    if(!item){
      bossActive = false;
      return;
    }

    // clear normal enemies
    enemies.forEach(e => { removeEnemy(e); });
    enemies.length = 0;
    currentTarget = null;

    bossHpMax = clamp(settings.bossHp|0, 1, 20);
    // scale with wrong pool a bit
    bossHpMax = clamp(bossHpMax + Math.min(6, bossKeyList.length-1), 1, 26);
    bossHp = bossHpMax;

    bossHud.style.display = "";
    updateBossHud();

    bossEnemy = makeEnemy(item, true);
    enemies.push(bossEnemy); // reuse array for movement
    chooseTarget();
      applyTargetHighlight();

    toast("ãƒœã‚¹å‡ºç¾ï¼å¾©ç¿’èªã‚’å€’ã› ğŸ“šğŸ‰");
  }

  function bossNextItem(){
    bossKeyList = Object.keys(wrongPool);
    if(!bossKeyList.length){
      endBoss(true);
      return null;
    }
    const k = pick(bossKeyList);
    const item = activeVocab.find(v => makeKey(v) === k) || weightedPickVocab();
    return item;
  }

  function updateBossHud(){
    bossTxt.textContent = `${bossHp}/${bossHpMax}`;
    bossBar.style.width = `${(bossHp / bossHpMax) * 100}%`;
  }

  function endBoss(victory){
    bossActive = false;
    bossEnemy = null;
    bossHud.style.display = "none";
    bossHp = 0; bossHpMax = 0;
    toast(victory ? "ãƒœã‚¹æ’ƒç ´ï¼å¾©ç¿’èªãŒå°‘ã—è»½ããªã£ãŸâœ¨" : "ãƒœã‚¹æ’¤é€€â€¦ã¾ãŸæ¥ã‚‹ã");
    chooseTarget();
      applyTargetHighlight();
  }

  // ----------------------------
  // Answer handling
  // ----------------------------
  function onCorrect(item, enemy){
    const st = ensureStat(item);
    st.correct += 1;
    st.last = "æ­£";
    hit += 1;
    seen += 1;


    // After-correct audio:
    // Always speak the *English* answer when you get it right (4æŠ/ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ä¸¡å¯¾å¿œ).
    // This happens after a correct action, so it doesn't spoil the question.
    if(settings.autoSpeak){
      const ansEn = item.en || "";
      if(ansEn) speak(ansEn, "en");
    }
    combo += 1;

    // Score: make it feel more arcade-y âœ¨
    // Base points are much higher, combo ramps faster,
    // and you get a small "danger bonus" when the word is closer to the bottom.
    const stageRect = stage.getBoundingClientRect();
    const danger = enemy ? clamp((enemy.y || 0) / Math.max(1, stageRect.height), 0, 1) : 0;
    const gain = 120 + (combo * 30) + Math.round(danger * 80);
    score += gain;

    // Milestone bonus (every 10 combo)
    if(combo > 0 && combo % 10 === 0){
      score += 500;
      toast(`COMBO x${combo}! +500`);
    }

    // if item is in wrong pool, reduce it slightly (learning effect)
    const k = makeKey(item);
    if(wrongPool[k]) decWrong(k);

    // boss damage
    if(bossActive){
      bossHp -= 1;
      updateBossHud();
      if(bossHp <= 0){
        // reward and end boss
        score += 1500 + bossHpMax*250;
        kills += 1; // count boss as a kill for pacing
        removeEnemy(enemy);
        enemies.length = 0;
        endBoss(true);
        return;
      }else{
        // swap boss word sometimes
        if(bossHp % 2 === 0){
          const next = bossNextItem();
          if(next){
            removeEnemy(enemy);
            enemies.length = 0;
            bossEnemy = makeEnemy(next, true);
            enemies.push(bossEnemy);
            chooseTarget();
      applyTargetHighlight();
          }
        }
        // add a little shake feedback
        enemy.el.classList.add("good");
        setTimeout(() => enemy.el?.classList.remove("good"), 220);
        return;
      }
    }

    // normal enemy removal
    kills += 1;
    enemy.el.classList.add("good");
    setTimeout(() => removeEnemy(enemy), 120);
    chooseTarget();
      applyTargetHighlight();
  }

  function onWrong(item, enemy, reason="èª¤"){
    const st = ensureStat(item);
    st.wrong += 1;
    st.last = reason;
    seen += 1;

    combo = 0;
    hp -= 1;
    hp = Math.max(0, hp);
    updateHp();

    addWrong(item);

    // feedback
    if(enemy?.el){
      enemy.el.classList.add("bad","shake");
      setTimeout(() => enemy.el?.classList.remove("shake"), 240);
    }

    if(hp <= 0){
      gameOver();
      return;
    }

    // boss penalty heavier
    if(bossActive){
      // don't remove boss; just keep going
      updateBossHud();
      toast("ç—›ã„ï¼ãƒœã‚¹ã®ä¸€æ’ƒ ğŸ’¥");
      return;
    }

    // normal: keep enemy (so you can retry), but mark it
    chooseTarget();
      applyTargetHighlight();
  }

  function updateHp(){
    hpTxt.textContent = `${hp}/${hpMax}`;
    hpBar.style.width = `${(hp/hpMax)*100}%`;
  }

  function updateHud(){
    hudScore.textContent = String(score|0);
    hudCombo.textContent = String(combo|0);
    const acc = seen ? Math.round((hit/seen)*100) : 0;
    hudAcc.textContent = `${acc}%`;
    resScore.textContent = String(score|0);
    resAcc.textContent = `${acc}%`;
    resBest.textContent = String(settings.bestScore|0);
  }

  function resetChoiceFeedbackLater(){
    setTimeout(() => resetChoiceStyles(), 280);
  }

  function answerChoice(i){
    if(!running || paused) return;
    if(mode !== "choice") return;
    if(!currentTarget || !currentTarget.alive) { chooseTarget(); return; }

    const correct = (i === correctIndex);
    const item = currentTarget.item;
    const btn = choiceBtns[i];

    if(correct){
      btn.classList.add("correct");
      resetChoiceFeedbackLater();
      onCorrect(item, currentTarget);
    }else{
      btn.classList.add("wrong");
      resetChoiceFeedbackLater();
      onWrong(item, currentTarget);
    }
    updateHud();
  }

  choiceBtns.forEach(btn => {
    btn.addEventListener("click", () => answerChoice(safeInt(btn.dataset.i, 0)));
  });


  function updateTypeMirror(){
    if(mode !== "typing") return;
    if(!typeMirror) return;

    if(!currentTarget || !currentTarget.item){
      typeMirror.innerHTML = "";
      typeInput.classList.remove("ok","ng");
      return;
    }

    const ansRaw = String(currentTarget.item.en ?? "");
    const ans = ansRaw.replace(/\s+/g,"").trim();
    const givenRaw = String(typeInput.value ?? "");
    const given = givenRaw.replace(/\s+/g,"").trim();

    if(!ans){
      typeMirror.innerHTML = `<span class="tiny muted">ç­”ãˆãŒã‚ã‚Šã¾ã›ã‚“</span>`;
      typeInput.classList.remove("ok","ng");
      return;
    }

    const aLower = ans.toLowerCase();
    const gLower = given.toLowerCase();

    let anyWrong = false;
    let out = `<span class="label">åˆ¤å®š:</span>`;

    for(let i=0; i<ans.length; i++){
      let cls = "tile pending";
      let display = "&nbsp;"; // do NOT reveal the answer before typing

      if(i < given.length){
        display = escapeHtml(given[i]);
        if(gLower[i] === aLower[i]) cls = "tile correct";
        else { cls = "tile wrong"; anyWrong = true; }
      }

      out += `<span class="${cls}">${display}</span>`;
    }

    // extra typed chars beyond answer length
    if(given.length > ans.length){
      for(let i=ans.length; i<given.length; i++){
        anyWrong = true;
        out += `<span class="tile wrong">${escapeHtml(given[i])}</span>`;
      }
    }

    // input border feedback
    typeInput.classList.toggle("ok", given.length > 0 && !anyWrong && given.length <= ans.length);
    typeInput.classList.toggle("ng", anyWrong);

    typeMirror.innerHTML = out;
  }

  function answerTyping(){
    if(!running || paused) return;
    if(mode !== "typing") return;
    if(!currentTarget || !currentTarget.alive) { chooseTarget(); return; }

    const item = currentTarget.item;
    const given = normKey(typeInput.value);
    const ans = normKey(item.en);

    if(!given){
      toast("å…¥åŠ›ãŒç©ºã§ã™");
      return;
    }
    if(given === ans){
      onCorrect(item, currentTarget);
    }else{
      toast(`é•ã†ã£ã½ã„â€¦ï¼ˆå…¥åŠ›: ${typeInput.value.trim()}ï¼‰`);
      onWrong(item, currentTarget);
    }
    updateHud();
  }

  btnEnter.addEventListener("click", answerTyping);
  typeInput.addEventListener("input", updateTypeMirror);
  typeInput.addEventListener("keydown", (e) => {
    if(e.key === "Enter"){ e.preventDefault(); answerTyping(); }
  });

  btnReveal.addEventListener("click", () => {
    if(!currentTarget) return;
    const it = currentTarget.item;
    toast(`ç­”ãˆ: ${it.en}`);
    // revealing counts as a wrong (soft)
    onWrong(it, currentTarget, "è¦‹");
    updateHud();
  });

  btnSkip.addEventListener("click", () => {
    if(!running || paused) return;
    if(!currentTarget) return;
    // soft penalty: reset combo but no HP
    combo = 0;
    const st = ensureStat(currentTarget.item);
    st.last = "S";
    chooseTarget();
      applyTargetHighlight();
    updateHud();
    toast("ã‚¹ã‚­ãƒƒãƒ—");
  });

  btnSpeak.addEventListener("click", () => {
    if(!currentTarget) return;
    // No audio for Japanese prompts (user preference)
    if(getPromptSide() === "ja") return;
    const it = currentTarget.item;
    const text = getPromptText(it);
    speak(text, it.lang);
  });

  // keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if(e.target && (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")) {
      // allow typing
      if(e.key === "Escape") e.target.blur();
      return;
    }
    if(e.key === " "){ e.preventDefault(); togglePause(); return; }
    if(e.key.toLowerCase() === "r"){ e.preventDefault(); restart(); return; }
    if(mode === "choice"){
      if(["1","2","3","4"].includes(e.key)) answerChoice(parseInt(e.key,10)-1);
    }
  });

  // ----------------------------
  // Game loop
  // ----------------------------
  function tick(){
    const t = now();
    const dt = (t - lastTick);
    lastTick = t;

    if(running && !paused){
      spawnIfNeeded(dt);

      const rect = stage.getBoundingClientRect();
      const h = rect.height;

      // update enemies
      for(const e of enemies){
        if(!e.alive) continue;
        e.y += (e.speed * dt / 1000);
        // position
        e.el.style.left = `${e.x}px`;
        e.el.style.top = `${e.y}px`;

        // bottom reached
        if(e.y > h - 18){
          // remove enemy and penalize
          e.alive = false;
          removeEnemy(e);
          // in boss mode, reaching bottom is heavy
          if(bossActive){
            hp -= 2;
            hp = Math.max(0, hp);
            updateHp();
            toast("ãƒœã‚¹ãŒçªç ´ã—ãŸï¼HP -2");
            if(hp <= 0){ gameOver(); break; }
            // respawn boss with next item
            const next = bossNextItem();
            if(next){
              enemies.length = 0;
              bossEnemy = makeEnemy(next, true);
              enemies.push(bossEnemy);
              chooseTarget();
      applyTargetHighlight();
            }
          }else{
            hp -= 1;
            hp = Math.max(0, hp);
            updateHp();
            addWrong(e.item);
            const st = ensureStat(e.item);
            st.wrong += 1;
            st.last = "è½";
            seen += 1;
            combo = 0;
            if(hp <= 0){ gameOver(); break; }
            chooseTarget();
      applyTargetHighlight();
          }
          updateHud();
        }
      }

      // cleanup array
      for(let i=enemies.length-1;i>=0;i--){
        if(!enemies[i].alive) enemies.splice(i,1);
      }

      // update target if missing
      if(!bossActive && (!currentTarget || !currentTarget.alive)) chooseTarget();
      applyTargetHighlight();
    }

    requestAnimationFrame(tick);
  }

  function removeEnemy(e){
    e.alive = false;
    if(e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
  }

  // ----------------------------
  // Start / pause / restart / over
  // ----------------------------
  function start(){
    if(running) return;
    running = true;
    paused = false;

    hpMax = clamp(safeInt(optHp.value, 5), 1, 20);
    hp = hpMax;

    score = 0; combo = 0; seen = 0; hit = 0; kills = 0;
    spawnTimer = 0;
    currentTarget = null;
    currentChoices = [];
    bossActive = false;
    bossHud.style.display = "none";

    // mode
    mode = optMode.value;
    hudMode.textContent = (mode === "typing") ? "ã‚¿ã‚¤ãƒ”ãƒ³ã‚°" : "4æŠ";
    // Apply 4-choice direction (no effect in typing)
    if(optChoiceDir){
      settings.choiceDirection = optChoiceDir.value || settings.choiceDirection || "en2ja";
      saveSettings();
    }


    // Typing mode pacing: slow down + widen gaps automatically
    recomputeEffectivePacing();

    if(mode === "typing"){
      // Typing is tough with many enemies; gently cap to 1 unless user insists
      if(safeInt(optMaxEnemies.value, 3) > 1){
        optMaxEnemies.value = "1";
      }
      toast("ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç”¨ã«é–“éš”ã‚’åºƒã’ã€è½ä¸‹ã‚’é…ãã—ã¾ã—ãŸ");
    }
    choicePanel.style.display = (mode === "typing") ? "none" : "";
    typingPanel.style.display = (mode === "typing") ? "" : "none";

    // Switch vocabulary pool for this mode
    setActiveVocabForMode();

    // clear stage
    enemies.forEach(removeEnemy);
    enemies.length = 0;

    updateHp();
    updateHud();
    setChoicesDisabled(false);

    btnStart.disabled = true;
    btnPause.disabled = false;
    btnRestart.disabled = false;

    toast("é–‹å§‹ï¼");

    // Spawn one immediately so typing input is available right away
    spawnTimer = -1;
    spawnIfNeeded(0);
    chooseTarget();
      applyTargetHighlight();
  }

  function togglePause(){
    if(!running) return;
    paused = !paused;
    btnPause.textContent = paused ? "å†é–‹" : "ä¸€æ™‚åœæ­¢";
    toast(paused ? "åœæ­¢ä¸­" : "å†é–‹");
    if(!paused && mode === "typing") typeInput.focus({preventScroll:true});
  }

  function restart(){
    if(!running){
      start();
      return;
    }
    // reset but keep loaded vocab and settings
    running = false;
    paused = false;
    btnPause.textContent = "ä¸€æ™‚åœæ­¢";
    btnStart.disabled = false;
    btnPause.disabled = true;
    btnRestart.disabled = true;
    setChoicesDisabled(true);

    // clear enemies
    enemies.forEach(removeEnemy);
    enemies.length = 0;
    currentTarget = null;
    bossActive = false;
    bossHud.style.display = "none";

    toast("ãƒªã‚¹ã‚¿ãƒ¼ãƒˆæº–å‚™OK");
  }

  function gameOver(){
    running = false;
    paused = false;
    btnStart.disabled = false;
    btnPause.disabled = true;
    btnRestart.disabled = true;
    setChoicesDisabled(true);

    // clear enemies
    enemies.forEach(removeEnemy);
    enemies.length = 0;

    // best score
    if(score > (settings.bestScore|0)){
      settings.bestScore = score|0;
      saveSettings();
    }

    updateHud();
    recordSession();
    refreshResults();
    openOverlay(ovResults);

    toast("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ â˜ ï¸");
  }

  btnStart.addEventListener("click", start);
  btnPause.addEventListener("click", togglePause);
  btnRestart.addEventListener("click", restart);

  // ----------------------------
  // Results
  // ----------------------------
  function refreshResults(){
    resScore.textContent = String(score|0);
    const acc = seen ? Math.round((hit/seen)*100) : 0;
    resAcc.textContent = `${acc}%`;
    resBest.textContent = String(settings.bestScore|0);

    // ranking pills (default: this CSV)
    updateDatasetId();
    const store = loadRankStore();
    const ds = store.datasets?.[datasetId];
    const sessionsCsv = (ds?.sessions || []);
    const sessionsAll = (store.allSessions || []);

    const rCsv = computeRank(sessionsCsv, score|0);
    const rAll = computeRank(sessionsAll, score|0);

    const tk = todayKey(Date.now());
    const todayCsv = sessionsCsv.filter(s => todayKey(s.ts) === tk);
    const todayAll = sessionsAll.filter(s => todayKey(s.ts) === tk);
    const rDayCsv = computeRank(todayCsv, score|0);
    const rDayAll = computeRank(todayAll, score|0);

    // show scope label and ranks; CSV rank is default shown in main results
    resRank.textContent = `${rCsv}ä½`;
    resRankDay.textContent = `${rDayCsv}ä½`;
    resRankCsv.textContent = (baseCsvLabel || "ã“ã®CSV");

    // build table
    const rows = Object.values(stats);
    rows.sort((a,b) => (b.wrong - a.wrong) || (b.correct - a.correct) || a.en.localeCompare(b.en));
    resTable.innerHTML = rows.map(r => {
      const last = r.last || "-";
      const lastClass = (last === "æ­£") ? "good" : (last === "èª¤" || last === "è½") ? "bad" : "";
      return `
        <tr>
          <td class="mono">${escapeHtml(r.en)}</td>
          <td>${escapeHtml(r.ja || "")}</td>
          <td class="right good mono">${r.correct|0}</td>
          <td class="right bad mono">${r.wrong|0}</td>
          <td class="right mono ${lastClass}">${escapeHtml(last)}</td>
        </tr>
      `;
    }).join("") || `<tr><td colspan="5" class="muted">ã¾ã å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>`;
  }

  btnClearStats.addEventListener("click", () => {
    stats = {};
    wrongPool = {};
    hudWrongPool.textContent = "0";
    toast("å±¥æ­´ã‚¯ãƒªã‚¢");
    refreshResults();
  });

  btnExportWrong.addEventListener("click", () => {
    const keys = Object.keys(wrongPool);
    if(!keys.length){ alert("å¾©ç¿’èªãŒã‚ã‚Šã¾ã›ã‚“"); return; }
    const lines = ["en,ja,level,lang,wrongCount"];
    for(const k of keys){
      const st = stats[k] || null;
      const it = st ? st : (() => {
        const [enKey, jaKey] = k.split("||");
        return {en: enKey, ja: jaKey, level:"", lang:""};
      })();
      const wc = wrongPool[k] || 0;
      lines.push([
        csvEscape(it.en), csvEscape(it.ja || ""),
        csvEscape(it.level ?? ""), csvEscape(it.lang ?? ""), csvEscape(wc)
      ].join(","));
    }
    downloadText(lines.join("\n"), "review_words.csv");
  });

  function csvEscape(s){
    const t = String(s ?? "");
    if(/[,"\n]/.test(t)) return '"' + t.replace(/"/g,'""') + '"';
    return t;
  }
  function downloadText(text, filename){
    const blob = new Blob([text], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  // ----------------------------
  // Settings apply / persistence
  // ----------------------------
  btnApplySettings.addEventListener("click", () => {
    // apply base speed (live)
    const newSpeed = clamp(safeInt(setBaseSpeed.value, 120), 40, 360);
    if(typeof applyBaseSpeed === "function"){ applyBaseSpeed(newSpeed); }
    else settings.baseSpeed = newSpeed;

    settings.spawnMs = clamp(safeInt(setSpawnMs.value, 900), 300, 3000);

    // recompute effective pacing after settings change
    recomputeEffectivePacing();

    const del = setDelimiter.value;
    settings.delimiter = (del === "tab") ? "\t" : del;

    settings.bossEvery = clamp(safeInt(setBossEvery.value, 15), 5, 50);
    settings.bossHp = clamp(safeInt(setBossHp.value, 6), 1, 20);
    settings.wrongWeight = clamp(safeInt(setWrongWeight.value, 3), 1, 10);

    settings.autoSpeak = !!setAutoSpeak.checked;
    settings.speakWhich = setSpeakWhich.value;
    settings.voiceLang = setVoiceLang.value;
    settings.rate = clamp(Number(setRate.value)||1.0, 0.5, 1.5);
    settings.pitch = clamp(Number(setPitch.value)||1.0, 0.5, 1.5);

    saveSettings();
    closeOverlay(ovSettings);
    toast("è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ");
  });

  btnResetBest.addEventListener("click", () => {
    if(!confirm("æœ€é«˜ã‚¹ã‚³ã‚¢ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) return;
    settings.bestScore = 0;
    saveSettings();
    toast("ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
  });

  // quick speed control (aside) - live apply even during play
  let lastBaseSpeed = settings.baseSpeed;

  function applyBaseSpeed(newSpeed){
    const ns = clamp(safeInt(newSpeed, settings.baseSpeed), 40, 360);
    if(ns === settings.baseSpeed) return;

    // ratio is applied to existing enemies using the *effective* speed,
    // so changes are felt immediately even in typing mode.
    const prevEffective = effectiveBaseSpeed || (settings.baseSpeed || 1);

    settings.baseSpeed = ns;
    recomputeEffectivePacing();
    const nextEffective = effectiveBaseSpeed || prevEffective;

    const ratio = nextEffective / (prevEffective || 1);

    // sync UI (base speed)
    optSpeedRange.value = String(ns);
    optSpeedNum.value = String(ns);
    setBaseSpeed.value = String(ns);

    // adjust existing enemies immediately
    for(const e of enemies){
      if(!e || !e.alive) continue;
      e.speed = Math.max(40, e.speed * ratio);
    }

    lastBaseSpeed = ns;
    saveSettings();

    if(mode === "typing"){
      toast(`ã‚¹ãƒ”ãƒ¼ãƒ‰(ãƒ™ãƒ¼ã‚¹): ${ns} â†’ å®ŸåŠ¹: ${effectiveBaseSpeed} px/ç§’`);
    }else{
      toast(`ã‚¹ãƒ”ãƒ¼ãƒ‰: ${ns} px/ç§’`);
    }
  }

  function syncSpeedUIFromSettings(){
    optSpeedRange.value = String(settings.baseSpeed);
    optSpeedNum.value = String(settings.baseSpeed);
  }

  optSpeedRange.addEventListener("input", () => applyBaseSpeed(optSpeedRange.value));
  optSpeedNum.addEventListener("change", () => applyBaseSpeed(optSpeedNum.value));

  // quick mode sync (aside)
  optMode.addEventListener("change", () => {
    // if game is running, reflect next restart
    hudMode.textContent = (optMode.value === "typing") ? "ã‚¿ã‚¤ãƒ”ãƒ³ã‚°" : "4æŠ";
    // reflect derived pacing preview
    mode = optMode.value;
    recomputeEffectivePacing();
    if(mode === "typing"){ toast(`ã‚¿ã‚¤ãƒ”ãƒ³ã‚°: å®ŸåŠ¹ã‚¹ãƒ”ãƒ¼ãƒ‰ ${effectiveBaseSpeed}px/ç§’ / é–“éš” ${effectiveSpawnMs}ms`); }
    toast("ãƒ¢ãƒ¼ãƒ‰å¤‰æ›´ã¯æ¬¡ã®é–‹å§‹/ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã§åæ˜ ");
  });

  // 4-choice direction (aside)
  optChoiceDir.addEventListener("change", () => {
    settings.choiceDirection = optChoiceDir.value || "en2ja";
    saveSettings();
    toast(settings.choiceDirection === "ja2en" ? "4æŠ: æ—¥æœ¬èªâ†’è‹±èª" : "4æŠ: è‹±èªâ†’æ—¥æœ¬èª");
    if(running && mode === "choice" && currentTarget?.item){
      renderQuestionFor(currentTarget.item);
    }
  });


  // ----------------------------
  // Toast
  // ----------------------------
  let toastTimer = null;
  const toastEl = document.createElement("div");
  toastEl.style.cssText = `
    position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
    background: rgba(18,26,51,.95);
    border: 1px solid rgba(255,255,255,.14);
    color: var(--ink);
    padding: 10px 12px;
    border-radius: 999px;
    box-shadow: 0 14px 30px rgba(0,0,0,.45);
    z-index: 99;
    font-size: 12px;
    opacity: 0;
    pointer-events: none;
    transition: opacity .12s ease, transform .12s ease;
  `;
  document.body.appendChild(toastEl);

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.style.opacity = "1";
    toastEl.style.transform = "translateX(-50%) translateY(-2px)";
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => {
      toastEl.style.opacity = "0";
      toastEl.style.transform = "translateX(-50%) translateY(0)";
    }, 1100);
  }

  // ----------------------------
  // Init
  // ----------------------------
  function init(){
    // initial hud
    baseCsvLabel = "å†…è”µã‚µãƒ³ãƒ—ãƒ«";
    hudCsv.textContent = baseCsvLabel;
    hudCount.textContent = vocab.length.toString();
    hudWrongPool.textContent = "0";
    hudBest.textContent = (settings.bestScore|0).toString();
    setChoicesDisabled(true);
    syncSettingsUI();
  showRankTab("session");
    // ensure quick speed UI reflects current settings
    if(typeof syncSpeedUIFromSettings === "function"){ syncSpeedUIFromSettings(); }

    // initial pacing
    recomputeEffectivePacing();

    // initial pool
    setActiveVocabForMode();

    setActiveVocabForMode();
    updateHp();
    updateHud();
    requestAnimationFrame(tick);
  }
  init();

})();
});
</script>

<div id="ovRank" class="overlay">
  <div class="panel">
    <div class="hd">
      <strong>ãƒ©ãƒ³ã‚­ãƒ³ã‚°</strong>
      <button class="btn small" data-close="ovRank">é–‰ã˜ã‚‹</button>
    </div>
    <div class="bd">
      <div class="row" style="justify-content:space-between">
        <div class="row" style="gap:8px; flex-wrap:wrap">
          <button class="btn small" id="tabRankSession">è‡ªå·±ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
          <button class="btn small" id="tabRankWords">è‹¦æ‰‹å˜èª</button>
          <button class="btn small" id="tabRankDaily">æ—¥åˆ¥</button>
        </div>
        <div class="row" style="gap:8px; flex-wrap:wrap">
          <span class="tiny muted">è¡¨ç¤º:</span>
          <select id="rankScope" class="input" style="max-width:160px">
            <option value="csv">ã“ã®CSV</option>
            <option value="all">å…¨CSV</option>
          </select>
        </div>
      </div>

      <div id="rankViewSession">
        <div class="row" style="justify-content:space-between; margin-bottom:8px">
          <div class="tiny muted">éå»ã®ã‚¹ã‚³ã‚¢å±¥æ­´ã‹ã‚‰ã€Œä»Šå›ã¯ä½•ä½ã€ã‚’å‡ºã—ã¾ã™ï¼ˆåŒç‚¹ã¯åŒé †ä½ï¼‰ã€‚</div>
          <div class="tiny muted"><span id="rankLabel"></span></div>
        </div>
        <div style="overflow:auto; border:1px solid var(--line); border-radius:16px">
          <table>
            <thead>
              <tr>
                <th class="right">ä½</th>
                <th class="right">ã‚¹ã‚³ã‚¢</th>
                <th class="right">å‘½ä¸­</th>
                <th>ãƒ¢ãƒ¼ãƒ‰</th>
                <th>æ—¥æ™‚</th>
              </tr>
            </thead>
            <tbody id="rankSessionTable"></tbody>
          </table>
        </div>
      </div>

      <div id="rankViewWords" style="display:none">
        <div class="row" style="justify-content:space-between; margin-bottom:8px">
          <div class="tiny muted"><span id="rankWordSortHint">é–“é•ã„ãŒå¤šã„é †ï¼ˆèª¤â–¼ â†’ æ­£è§£ç‡â–² â†’ ABCï¼‰ã€‚</span></div>
          <div class="tiny muted"><span id="rankLabel2"></span></div>
        </div>
        <div style="overflow:auto; border:1px solid var(--line); border-radius:16px">
          <table>
            <thead>
              <tr>
                <th>å˜èª</th>
                <th>æ„å‘³</th>
                <th class="right"><button class="thbtn rankSortBtn" data-sort="correct" type="button">æ­£<span class="arrow" id="sortArrowCorrect"></span></button></th>
                <th class="right"><button class="thbtn rankSortBtn" data-sort="wrong" type="button">èª¤<span class="arrow" id="sortArrowWrong"></span></button></th>
                <th class="right"><button class="thbtn rankSortBtn" data-sort="acc" type="button">æ­£è§£ç‡<span class="arrow" id="sortArrowAcc"></span></button></th>
              </tr>
            </thead>
            <tbody id="rankWordTable"></tbody>
          </table>
        </div>
      </div>

      <div id="rankViewDaily" style="display:none">
        <div class="row" style="justify-content:space-between; margin-bottom:8px">
          <div class="tiny muted">æ—¥ã”ã¨ã®ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ã€‚</div>
          <div class="tiny muted"><span id="rankLabel3"></span></div>
        </div>
        <div style="overflow:auto; border:1px solid var(--line); border-radius:16px">
          <table>
            <thead>
              <tr>
                <th>æ—¥ä»˜</th>
                <th class="right">ãƒ™ã‚¹ãƒˆ</th>
                <th class="right">å›æ•°</th>
              </tr>
            </thead>
            <tbody id="rankDailyTable"></tbody>
          </table>
        </div>
      </div>

      <div class="tiny muted" style="margin-top:10px">
        â€» åˆ¥ã®CSVã‚’èª­ã¿è¾¼ã‚€ã¨ã€ã€Œã“ã®CSVã€ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã¯åˆ¥æ ã«ãªã‚Šã¾ã™ï¼ˆæ··ã–ã‚Šã¾ã›ã‚“ï¼‰ã€‚ãŸã ã—ã€Œå…¨CSVã€ã‚’é¸ã¶ã¨åˆç®—ã—ã¦è¦‹ã‚‰ã‚Œã¾ã™ã€‚
      </div>
    </div>
  </div>
</div>

</body>
</html>